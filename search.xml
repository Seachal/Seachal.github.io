<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F03%2F16%2FJava%2FMac%20OS%20%E4%B8%8B%E7%9A%84Java%E7%8E%AF%E5%A2%83-2019-03-06%2F</url>
    <content type="text"><![CDATA[# Mac 下 Java的安装位置查看 先去Oracle官网下载地址下载JDK并安装, 2.查找JDK安装路径: $ ls -l /usr/bin/java 回到桌面,点击**`前往 -&gt; 前往文件夹`**，拷贝路径**`/System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/java`**进入当前路径,之后会是这样子: 实际上这个只是替身路径,编译路径,我们要找的是另一个路径，在此页面,点击资源库（注意次文件夹和系统同级）,下面的路径： 点在Home文件夹上,右键-查看简介: 选择拷贝,打开文本编辑器,粘贴之后就是JDK的正确安装路径了。我的是 /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home这个。 切换 Mac 下 Java 的版本，How to set or change the default Java (JDK) version on OS X? 依照网上的很多文章，uiautomatorviewer 做为一个sdk中自带的、方便用来定位APP中元素的工具，直接在sdk/tools/bin/uiautomatorviewer文件夹下找到uiautomatorviewer文件，点击打开就可以了。但当我找到并打开之后，并没有出现期望中的图形化界面，命令行中给了我这样一个结果：Error:Could not create the Java Virtual Machine网上找的解决方法是使用Java8就没问题 我本地安装了很多Java 版本所以就在网上找切换Java的方法如下。 首次运行/usr/libexec/java_home -V将输出如下内容： 12345$ /usr/libexec/java_home -VMatching Java Virtual Machines (3): 10.0.2, x86_64: "Java SE 10.0.2" /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home 9.0.4, x86_64: "Java SE 9.0.4" /Library/Java/JavaVirtualMachines/jdk-9.0.4.jdk/Contents/Home 1.8.0_141, x86_64: "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_141.jdk/Contents/Home 选择您想要的默认版本（9.0.4为了参数），然后： 1export JAVA_HOME=`/usr/libexec/java_home -v 9.0.4` 或者您只能指定主要版本，例如： 1export JAVA_HOME=`/usr/libexec/java_home -v 1.8` 现在，当你run时，java -version你会看到： 1234java -versionjava version "1.8.0_141"Java(TM) SE Runtime Environment (build 1.8.0_141-b15)Java HotSpot(TM) 64-Bit Server VM (build 25.141-b15, mixed mode) 只需将该export JAVA_HOME…行添加到shell的init文件中即可。 参考：https://stackoverflow.com/questions/21964709/how-to-set-or-change-the-default-java-jdk-version-on-os-x 更方便的切换打开 /Users/用户/.bash_profile文件，添加如下内容 1234567891011121314# 设置 JDK 8export JAVA_8_HOME=`/usr/libexec/java_home -v 1.8`# 设置 JDK 9 export JAVA_9_HOME=`/usr/libexec/java_home -v 9`# 设置 JDK 10export JAVA_10_HOME=`/usr/libexec/java_home -v 10`#默认JDK 8export JAVA_HOME=$JAVA_8_HOME#alias命令动态切换JDK版本alias jdk8="export JAVA_HOME=$JAVA_8_HOME"#alias jdk9="export JAVA_HOME=$JAVA_9_HOME"#alias jdk8="export JAVA_HOME=$JAVA_10_HOME" 执行source .bash_profile命令，此时再使用java -version命令此时显示默认java版本就是1.6了。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F03%2F16%2FAndroid%2FGithub%20Library%2FpictureSelector%2F</url>
    <content type="text"><![CDATA[# pictureSelector 选择图片的开源库测试从A页面到 选择图片页面（B），点击B上的按钮后B 回到到A的过程中， B大约需要1S的时间关闭的原因是什么。A 通过 StartActivityforresult 启动， B关闭后回到A.A页面使用了 BGA-zxing B ok1 1527488490790 ok2 1527488490790 ok3 1527488490811 Bactivity关闭 会返回到A Activity。 A onCreate1527488485885 onStart 1527488485887 onResume 1527488486233 onStop1527488488353 onStart 1527488490846 B关闭返回到A 可以看到B 关闭回到A耗时非常短（ok2 和本onstart的差值 ），其实 onResume 1527488491218 onStop 1527488494359 onDestroy1527488494359 A2是一个简单页面 B Activity ok1 1527489826242 ok2 1527489826242 ok3 1527489826278 A2 Activity onCreate 1527489817153 onStart1527489817156 onResume1527489817157 onStop1527489820219 onStart 1527489826319 onResume 1527489826319 onStop1527489886202 得出结论， 相较于A2，A页面使用了Zxing，zxing比较耗时。所以，耗时发生在 A页面再次 onResume， BGAQRCode 中，onStart到onResume速度特别快。BGAQRCode使用的事自己图片选择。onCreate1527492375031onStart1527492375434onResume1527492375434 onStop 1527492380028onStart 1527492381807onResume 1527492381807]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F03%2F16%2FAndroid%2FGithub%20Library%2F%E5%9B%BE%E8%A1%A8%E5%BC%80%E6%BA%90%E5%BA%93MPAndroidChart%2F</url>
    <content type="text"><![CDATA[图表开源库MPAndroidChart的使用 使用版本3.0.3 chart 的一些使用规则 一个 linechart 需要两个ArrayList，其他chart 也类似。 ArrayList xList, ArrayList yList; xList he yList的size相等。 （i,x）与 （i,y）基于i相交于一点才会绘制在 view中。 1.lineChart 1.1 123456789// 关于图表的描述 int textColor = ContextCompat.getColor(mActivity, R.color.stage_text); Description description = new Description(); description.setText("周"); description.setTextColor(textColor); description.setTextSize(12); description.setXOffset(5); description.setYOffset(-15);// 相对于Y位置偏移量 mChart.setDescription(description); //图表默认右下方的描述， 1.2 12345678910//图例设置 图例（声明颜色line， 颜色bar代表什么数据， 如红色代表订购率 ）Legend legend = mChart.getLegend();legend.setHorizontalAlignment(Legend.LegendHorizontalAlignment.RIGHT);//设置图例水平对齐, 居右侧legend.setVerticalAlignment(Legend.LegendVerticalAlignment.TOP);// 居上侧legend.setOrientation(Legend.LegendOrientation.HORIZONTAL);// 水平legend.setDrawInside(true); //legend.setDirection(Legend.LegendDirection.LEFT_TO_RIGHT);// 颜色在左 文字在右legend.setForm(Legend.LegendForm.LINE);////设置图例形状， SQUARE(方格) CIRCLE（圆形） LINE（线性）legend.setTextSize(12f);legend.setEnabled(true); 1.3 y轴 123456789101112//y轴设置 左侧 YAxis leftAxis = mChart.getAxisLeft(); leftAxis.setPosition(YAxis.YAxisLabelPosition.OUTSIDE_CHART);//设置y-labels显示的位置 leftAxis.setDrawGridLines(true);//绘制y网格线 leftAxis.enableGridDashedLine(4f, 2f, 0f);//启用网格虚线 leftAxis.setTextColor(barColor);//label字体颜色 leftAxis.setTextSize(11);//label字体大小 leftAxis.setLabelCount(Y_LABEL_COUNT, false);//y label显示的数量 leftAxis.setDrawLabels(true);//折线上显示值，则不显示坐标轴上的值 leftAxis.setAxisMinimum(0f); IAxisValueFormatter leftFormaterr = new MyLeftYAxisValueFormatter(); leftAxis.setValueFormatter(leftFormaterr); IAxisValueFormatter 格式话坐标的显示方式例如给y轴的所有刻度值后面都加上 ”条“、”%“ 1.4 绘制line或者bar等等 12345678910111213141516171819202122ArrayList&lt;ILineDataSet&gt; dataSets = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; entriesList.size(); ++i) &#123; LineDataSet set = new LineDataSet(entriesList.get(i), titles[i]); if (lineColors != null) &#123; set.setColor(lineColors[i]); set.setCircleColor(lineColors[i]); set.setCircleColorHole(Color.WHITE); &#125; else &#123; set.setColor(LINE_COLORS[i % 3]); set.setCircleColor(LINE_COLORS[i % 3]); set.setCircleColorHole(Color.WHITE); &#125; set.setCircleRadius(2.0f);//折线上圆点的大小。 set.setMode(LineDataSet.Mode.HORIZONTAL_BEZIER);//设置折线图样式 圆滑曲线 平滑曲线 或者 折线 set.setLineWidth(1.5f);//线的宽度（线的粗度） set.setDrawCircles(true);//禁止显示数据坐标圆点 //设置显示/不显示 在坐标点上方显示坐标值。 set.setDrawValues(false); //Enables / disables drawing values (value-text) for all DataSets this data object contains. set.setAxisDependency(YAxis.AxisDependency.RIGHT);// 数值属于右侧Y轴 setRightAxisMaximum(deliveryLevelTrend); dataSets.add(set); &#125; 2.barChart3.CombinedChart3.112345678910111213CombinedData data = new CombinedData(); data.setData(generateLineData()); data.setData(generateBarData()); data.setData(generateBubbleData()); data.setData(generateScatterData()); data.setData(generateCandleData()); data.setValueTypeface(mTfLight); xAxis.setAxisMaximum(data.getXMax() + 0.25f); mChart.setData(data); mChart.invalidate(); 所有数据都必须set到一个 CombinedData中去，不然是会报错的。也很好立即， CombinedChart就是把所有的图表整合为一个。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F03%2F16%2FAndroid%2Ftools%2FAndroid%20UI%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7uiautomatorviewer%20%202019-03-06%2F</url>
    <content type="text"><![CDATA[Android UI分析工具uiautomatorviewer工具介绍以前是用HierarchyViewer查看界面的布局层次的，其实UiAutomatorViewer用起来更方便更直观，个人更偏向后者。 UiAutomatorViewer也是Android sdk自带的工具，在如下路径（我的是AS 3.0，不同版本似乎有差别）：\sdk\tools\bin\uiautomatorviewer双击就可运行。 将手机连接到设备上，在手机上启动一个需要测试的目标页面，然后点击uiautomatorviewer左上角的第二个按钮（Device Screenshot(uiautomator dump)），便可以把当前页面截下来了 uiautomatorviewer的界面分成了3个部分： 左边部分：显示当前屏幕的截图。在这个部分，我们可以对这个页面上的各个控件做一些选中的操作。 右上角部分：显示当前页面的View层级。 右下角部分：显示当前选中控件的各个属性。 resource-id便是这个控件的id 豆瓣电影底部换上去的 panel分析 在手机上操作吧得底部panel划上去后，再次点击uiautomatorviewer工具界面的左上角第二个按钮就，就会更新次工具界面的数据。 小组的 panel划上去 可以看出滑上来的panel挡住之前页面显示的内容。 参考：https://blog.csdn.net/l403040463/article/details/79235670https://segmentfault.com/a/1190000004367222https://www.jianshu.com/p/2d7a63455c83]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F03%2F16%2FAndroid%2FGithub%20Library%2FEasyPermission%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2019-02-28%2F</url>
    <content type="text"><![CDATA[EasyPermission 源码分析使用EasyPermission时没搞懂怎样从 EasyPermissions中 build出一个 rational dialog的，所以简单分析了一下源码， 分析版本 是2.0.1 Rationale Dialog 什么条件下显示反向使用 1. 123456789@Overridepublic void onRationaleAccepted(int requestCode) &#123; Log.d(TAG, "onRationaleAccepted:" + requestCode);&#125;@Overridepublic void onRationaleDenied(int requestCode) &#123; Log.d(TAG, "onRationaleDenied:" + requestCode);&#125; 看到这两行代码，验证是 Rationale dialog的回调。2.找到onRationaleAccepted被调用的地方3.找到调用 持有RationaleDialogClickListener对象的类 RationaleDialogFragment4.找到持有 RationaleDialogFragment对象的类ActivityPermissionHelper5.找到PermissionHelper6.最后就找到了EasyPermissions 正向因为早上状态不佳，有些代码没看太清楚，导致正向推断没有成功，反向推断后，再从正向去看，原来是一些小细节被自己忽略了。 1234567891011121314151617181920212223242526272829303132333435363738/** * Request permissions from a Support Fragment with standard OK/Cancel buttons. * * @see #requestPermissions(Activity, String, int, String...) */ public static void requestPermissions( @NonNull Fragment host, @NonNull String rationale, int requestCode, @Size(min = 1) @NonNull String... perms) &#123; requestPermissions( new PermissionRequest.Builder(host, requestCode, perms) .setRationale(rationale) .build()); &#125; /** * Request a set of permissions. * * @param request the permission request * @see PermissionRequest */ public static void requestPermissions(PermissionRequest request) &#123; // Check for permissions before dispatching the request if (hasPermissions(request.getHelper().getContext(), request.getPerms())) &#123; notifyAlreadyHasPermissions( request.getHelper().getHost(), request.getRequestCode(), request.getPerms()); return; &#125; // Request permissions request.getHelper().requestPermissions( request.getRationale(), request.getPositiveButtonText(), request.getNegativeButtonText(), request.getTheme(), request.getRequestCode(), request.getPerms()); &#125; 有多个参数的requestPermissions（）调用了只有一个参数的requestPermissions（）方法， 1getHelper().requestPermissions（） 方法把dialog相关的参数传递给PermissionHelper 。然后按照 # 反向 中的6-5-4-3-2-1就看出调用关系了。 Dialog123456789101112131415161718public static RationaleDialogFragment newInstance( @NonNull String positiveButton, @NonNull String negativeButton, @NonNull String rationaleMsg, @StyleRes int theme, int requestCode, @NonNull String[] permissions) &#123; // Create new Fragment RationaleDialogFragment dialogFragment = new RationaleDialogFragment(); // Initialize configuration as arguments RationaleDialogConfig config = new RationaleDialogConfig( positiveButton, negativeButton, rationaleMsg, theme, requestCode, permissions); dialogFragment.setArguments(config.toBundle()); return dialogFragment; &#125; AppSettingsDialog 如何打开设置页的。1.AppSettingsDialog 12345678910111213141516171819/** * Show the dialog. &#123;@link #show()&#125; is a wrapper to ensure backwards compatibility */ AlertDialog showDialog(DialogInterface.OnClickListener positiveListener, DialogInterface.OnClickListener negativeListener) &#123; AlertDialog.Builder builder; if (mThemeResId != -1) &#123; builder = new AlertDialog.Builder(mContext, mThemeResId); &#125; else &#123; builder = new AlertDialog.Builder(mContext); &#125; return builder .setCancelable(false) .setTitle(mTitle) .setMessage(mRationale) .setPositiveButton(mPositiveButtonText, positiveListener) .setNegativeButton(mNegativeButtonText, negativeListener) .show(); &#125; 2.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F03%2F16%2FAndroid%2FGithub%20Library%2F2018-05-28%2F</url>
    <content type="text"><![CDATA[Android开发在onResume中执行耗时操作导致从其他界面返回特别慢 以pictureSelector 为基础，做的验证试验。 今天改别人的一个bug时遇见一个问题，发现某个界面点击返回以后特别慢，得等一会儿才能返回到上一个界面。 当时第一反应可能是在点击返回的时候或者是在Activity的onDestroy里面做了很多耗时的操作导致点击返回的时候出现特别慢的问题，但是仔细查看了一下代码发现在返回按钮的监听或者是设备返回键的监听都没有做什么操作，onDestroy里同样没做什么操作，这就奇怪了问题到底出在哪里呢？ 经过一番查找调试分析，觉得问题可能不是出在当前界面，将视线转到要返回的上一个界面，发现重写了onResume方法，可能是这个方法执行了耗时的操作导致的，打印了一下这个方法的耗时时间发现耗时也不是很高啊还不到10ms，难道问题的关键不是在这里？ 为了验证我的想法我自己写了个demo，在AActivity的onResume里执行Thread.sleep(10000)睡眠10秒，跳转到BActivity然后点击返回。果然，当点击返回的时候会B会停5秒左右关闭，然后黑屏5秒左右才会回到AActivity。代码如下 1234567891011@Override protected void onResume() &#123; try &#123; Thread.sleep(10000); Log.i(TAG, "Resume1000"+System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; super.onResume(); Log.i(TAG, "onResume"+System.currentTimeMillis()); &#125; 通过demo说明问题很有可能是出在onResume里面，再仔细看了看onResume里的代码，发现在onResume里执行了handler.sendMessage发送消息，会不会是在handler里面执行的代码耗时里，调试一下发现果然是这里面的代码出现了耗时的操作。 找到问题所在了就好办了，将这段耗时的操作提取到线程里执行，执行完后再使用handler通知UI刷新界面，ok重新运行程序，测试一下，点击返回很流畅，搞定。 记录一下免得自己以后也在开发中犯同样的错误。 思考页面优化 页面速度 写这个例子是，遇到的自己掌握不牢固的问题。 1.Thread 1.1 错误的演示代码： 123456789101112131415161718192021222324@Override protected void onResume() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; resume(); Log.i(TAG, "Resume3000"+System.currentTimeMillis()); &#125; &#125;).start(); Log.i(TAG, "onResume"+System.currentTimeMillis()); &#125; private void resume()&#123; super.onResume(); &#125; 1.2 代码 123456789101112131415161718192021@Overrideprotected void onResume() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; Log.i(TAG, "Resume3000"+System.currentTimeMillis()); &#125; &#125;).start(); super.onResume(); Log.i(TAG, "onResume"+System.currentTimeMillis());&#125; 结果： 12I/SimpleViewActivity: onResume1527517858625I/SimpleViewActivity: Resume30001527517861619 结论： new Thread 创建了新的线程， （是异步的了？），所以，线程内的代码执行的比线程代码下面的代码晚。 http://itindex.net/detail/54784-android-%E7%BA%BF%E7%A8%8B-%E5%A4%A7%E5%9D%91]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F03%2F16%2FAndroid%2FGithub%20Library%2FBGAQRCode%2F</url>
    <content type="text"><![CDATA[# QRCodeView 是抽象类， 这样ZxingView，ZbarView就可以更好的根据自己的特性进行拓展， ScanBoxView 是真正的扫描框 12345678910111213141516171819202122232425262728293031&lt;cn.bingoogolapple.qrcode.zxing.ZXingView android:id="@+id/zxingview" style="@style/MatchMatch" app:qrcv_animTime="1000" app:qrcv_barCodeTipText="将条码放入框内，即可自动扫描" app:qrcv_barcodeRectHeight="120dp" app:qrcv_borderColor="@android:color/white" app:qrcv_borderSize="1dp" app:qrcv_cornerColor="@color/colorPrimaryDark" app:qrcv_cornerLength="20dp" app:qrcv_cornerSize="3dp" app:qrcv_customScanLineDrawable="@drawable/scan_icon_scanline" app:qrcv_isBarcode="false" app:qrcv_isCenterVertical="false" app:qrcv_isOnlyDecodeScanBoxArea="false" app:qrcv_isScanLineReverse="true" app:qrcv_isShowDefaultGridScanLineDrawable="false" app:qrcv_isShowDefaultScanLineDrawable="true" app:qrcv_isShowTipBackground="true" app:qrcv_isShowTipTextAsSingleLine="false" app:qrcv_isTipTextBelowRect="false" app:qrcv_maskColor="#33FFFFFF" app:qrcv_qrCodeTipText="将二维码/条码放入框内，即可自动扫描" app:qrcv_rectWidth="200dp" app:qrcv_scanLineColor="@color/colorPrimaryDark" app:qrcv_scanLineMargin="0dp" app:qrcv_scanLineSize="0.5dp" app:qrcv_tipTextColor="@android:color/white" app:qrcv_tipTextSize="12sp" app:qrcv_toolbarHeight="56dp" app:qrcv_topOffset="20dp"/&gt; 在xml中的很多参数是借ZXingView（QRCodeView）传给了ScanBoxView。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F03%2F04%2FAndroid%2FaddTextChangedListener%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%952019-02-13%2F</url>
    <content type="text"><![CDATA[addTextChangedListener的三个方法123456789101112131415161718mEtPassword.addTextChangedListener(new TextWatcher() &#123; @Override public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123; //s:变化前的所有字符； start:字符开始的位置； count:；after:变化后的字节数 Log.i("Seachal:", "beforeTextChanged:s=" + s + ";" + "start:" + start + ";" + "count:" + count + ";" + "after:" + after); &#125; @Override public void onTextChanged(CharSequence s, int start, int before, int count) &#123; //S：变化后的所有字符；start：字符起始的位置；before: ；count:变化后的字节数 Log.i("Seachal:", "onTextChanged:s=" + s + ";" + "start:" + start + ";" + "before:" + before + ";" + "count:" + count); &#125; @Override public void afterTextChanged(Editable s) &#123; //s:变化后的所有字符 Log.i("Seachal:", "afterTextChanged:s=" + s + ";=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"); 1.从未输入任何字符开始输入 test log的变化 123456789101112I/Seachal:: beforeTextChanged:s=;start:0;count:0;after:1I/Seachal:: onTextChanged:s=t;start:0;before:0;count:1I/Seachal:: afterTextChanged:s=t;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;I/Seachal:: beforeTextChanged:s=t;start:1;count:0;after:1I/Seachal:: onTextChanged:s=te;start:1;before:0;count:1I/Seachal:: afterTextChanged:s=te;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;I/Seachal:: beforeTextChanged:s=te;start:2;count:0;after:1I/Seachal:: onTextChanged:s=tes;start:2;before:0;count:1I/Seachal:: afterTextChanged:s=tes;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;I/Seachal:: beforeTextChanged:s=tes;start:3;count:0;after:1I/Seachal:: onTextChanged:s=test;start:3;before:0;count:1I/Seachal:: afterTextChanged:s=test;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2.在 test 基础上增加字符23看变化 123456I/Seachal:: beforeTextChanged:s=test;start:4;count:0;after:1I/Seachal:: onTextChanged:s=test2;start:4;before:0;count:1I/Seachal:: afterTextChanged:s=test2;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;I/Seachal:: beforeTextChanged:s=test2;start:5;count:0;after:1I/Seachal:: onTextChanged:s=test23;start:5;before:0;count:1I/Seachal:: afterTextChanged:s=test23;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3.在test23基础上删除23看变化 123456beforeTextChanged:s=test23;start:5;count:1;after:0onTextChanged:s=test2;start:5;before:1;count:0afterTextChanged:s=test2;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;beforeTextChanged:s=test2;start:4;count:1;after:0onTextChanged:s=test;start:4;before:1;count:0afterTextChanged:s=test;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 4.在test基础上三处st并立即输入45看变化 123456789101112beforeTextChanged:s=test;start:3;count:1;after:0onTextChanged:s=tes;start:3;before:1;count:0afterTextChanged:s=tes;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;beforeTextChanged:s=tes;start:2;count:1;after:0onTextChanged:s=te;start:2;before:1;count:0afterTextChanged:s=te;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;beforeTextChanged:s=te;start:2;count:0;after:1onTextChanged:s=te4;start:2;before:0;count:1afterTextChanged:s=te4;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;beforeTextChanged:s=te4;start:3;count:0;after:1onTextChanged:s=te45;start:3;before:0;count:1afterTextChanged:s=te45;=&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 结论每发生一个字符变化，就会触发 beforeTextChanged，onTextChanged，afterTextChanged方法。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F03%2F04%2FAndroid%2F%E5%9C%A8%E9%9D%9EActivity%E4%B8%AD%E4%BD%BF%E7%94%A8startActivity-2019-03-04%2F</url>
    <content type="text"><![CDATA[在非Activity页面，不方便获取context的地方，调用自定义的startActivity（）在LoginActivity中 12345public static void startActivity() &#123; Intent intent = new Intent(TerminalApp.getInstance(), LoginActivity.class); intent.putExtra(AppConst.ERROR_PROCESSOR_KEY, true); TerminalApp.getInstance().startActivity(intent); &#125; 在异常拦截器里调用startActivity，1234567891011121314151617181920212223242526272829/** * TODO: 异常的一个拦截器 */public class ErrorInterceptor&lt;T&gt; implements Func1&lt;Throwable, Observable&lt;T&gt;&gt; &#123; @Override public Observable&lt;T&gt; call(Throwable throwable) &#123; Log.i("ErrorInterceptor", "跳转到登录页"); // 后台静默登录后，还是token失效，跳转到强制登录页登录 if (throwable instanceof ApiException) &#123; ApiException ex = (ApiException) throwable; // token失效 if (ex.getCode() == ApiCode.Http.UNAUTHORIZED) &#123; // 强制跳转到到登录页 Log.i("ErrorInterceptor跳转到登录页", ex.getCode() + "");// Intent intent = new Intent(TerminalApp.getInstance(), LoginActivity.class);// intent.putExtra(AppConst.ERROR_PROCESSOR_KEY,true);// mContext.startActivity(intent); LoginActivity.startActivity(); return null; &#125; else &#123; return Observable.error(ex); &#125; &#125; // return Observable.error(throwable); return Observable.error(ApiException.handleException(throwable)); &#125;&#125; 错误提示信息12Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want? 解决方案 1myIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 参考：https://stackoverflow.com/questions/3918517/calling-startactivity-from-outside-of-an-activity-context]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F28%2FAndroid%2F%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E8%AF%B7%E6%B1%82%E6%9D%83%E9%99%90-2019-01-15%2F</url>
    <content type="text"><![CDATA[在运行时请求权限转载自：https://developer.android.com/training/permissions/requesting?hl=zh-cn 在运行时请求权限从 Android 6.0（API 级别 23）开始，用户开始在应用运行时向其授予权限，而不是在应用安装时授予。此方法可以简化应用安装过程，因为用户在安装或更新应用时不需要授予权限。它还让用户可以对应用的功能进行更多控制；例如，用户可以选择为相机应用提供相机访问权限，而不提供设备位置的访问权限。用户可以随时进入应用的“Settings”屏幕调用权限。 系统权限分为两类：正常权限和危险权限： 正常权限不会直接给用户隐私权带来风险。如果您的应用在其清单中列出了正常权限，系统将自动授予该权限。 危险权限会授予应用访问用户机密数据的权限。如果您的应用在其清单中列出了正常权限，系统将自动授予该权限。如果您列出了危险权限，则用户必须明确批准您的应用使用这些权限。 如需了解详细信息，请参阅正常权限和危险权限。 在所有版本的 Android 中，您的应用都需要在其应用清单中同时声明它需要的正常权限和危险权限，如声明权限中所述。不过，该声明的影响因系统版本和应用的目标 SDK 级别的不同而有所差异： 如果设备运行的是 Android 5.1 或更低版本，或者应用的目标 SDK 为 22 或更低：如果您在清单中列出了危险权限，则用户必须在安装应用时授予此权限；如果他们不授予此权限，系统根本不会安装应用。 如果设备运行的是 Android 6.0 或更高版本，或者应用的目标 SDK 为 23 或更高：应用必须在清单中列出权限，并且它必须在运行时请求其需要的每项危险权限。用户可以授予或拒绝每项权限，且即使用户拒绝权限请求，应用仍可以继续运行有限的功能。 注：从 Android 6.0（API 级别 23）开始，用户可以随时从任意应用调用权限，即使应用面向较低的 API 级别也可以调用。无论您的应用面向哪个 API 级别，您都应对应用进行测试，以验证它在缺少需要的权限时行为是否正常。 本课将介绍如何使用 Android 支持库来检查和请求权限。Android 框架从 Android 6.0（API 级别 23）开始提供类似方法。不过，使用支持库更简单，因为在调用方法前，您的应用不需要检查它在哪个版本的 Android 上运行。 检查权限如果您的应用需要危险权限，则每次执行需要这一权限的操作时您都必须检查自己是否具有该权限。用户始终可以自由调用此权限，因此，即使应用昨天使用了相机，它不能假设自己今天仍具有该权限。 要检查您是否具有某项权限，请调用 ContextCompat.checkSelfPermission()) 方法。例如，以下代码段显示了如何检查 Activity 是否具有在日历中进行写入的权限： 12// Assume thisActivity is the current activityint permissionCheck = ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.WRITE_CALENDAR); 如果应用具有此权限，方法将返回 PackageManager.PERMISSION_GRANTED，并且应用可以继续操作。如果应用不具有此权限，方法将返回 PERMISSION_DENIED，且应用必须明确向用户要求权限。 请求权限如果您的应用需要应用清单中列出的危险权限，那么，它必须要求用户授予该权限。Android 为您提供了多种权限请求方式。调用这些方法将显示一个标准的 Android 对话框，不过，您不能对它们进行自定义。 解释应用为什么需要权限 图 1. 提示用户授予或拒绝权限的系统对话框。 在某些情况下，您可能需要帮助用户了解您的应用为什么需要某项权限。例如，如果用户启动一个摄影应用，用户对应用要求使用相机的权限可能不会感到吃惊，但用户可能无法理解为什么此应用想要访问用户的位置或联系人。在请求权限之前，不妨为用户提供一个解释。请记住，您不需要通过解释来说服用户；如果您提供太多解释，用户可能发现应用令人失望并将其移除。 您可以采用的一个方法是仅在用户已拒绝某项权限请求时提供解释。如果用户继续尝试使用需要某项权限的功能，但继续拒绝权限请求，则可能表明用户不理解应用为什么需要此权限才能提供相关功能。对于这种情况，比较好的做法是显示解释。 为了帮助查找用户可能需要解释的情形，Android 提供了一个实用程序方法，即 shouldShowRequestPermissionRationale())。如果应用之前请求过此权限但用户拒绝了请求，此方法将返回 true。 注：如果用户在过去拒绝了权限请求，并在权限请求系统对话框中选择了 Don’t ask again 选项(中文系统为：不再询问)，此方法将返回 false。如果设备规范禁止应用具有该权限，此方法也会返回 false。 请求您需要的权限如果应用尚无所需的权限，则应用必须调用一个 requestPermissions()) 方法，以请求适当的权限。应用将传递其所需的权限，以及您指定用于识别此权限请求的整型请求代码。此方法异步运行：它会立即返回，并且在用户响应对话框之后，系统会使用结果调用应用的回调方法，将应用传递的相同请求代码传递到 requestPermissions())。 以下代码可以检查应用是否具备读取用户联系人的权限，并根据需要请求该权限： 1234567891011121314151617181920212223242526// Here, thisActivity is the current activityif (ContextCompat.checkSelfPermission(thisActivity, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) &#123; // Should we show an explanation? if (ActivityCompat.shouldShowRequestPermissionRationale(thisActivity, Manifest.permission.READ_CONTACTS)) &#123; // Show an expanation to the user *asynchronously* -- don't block // this thread waiting for the user's response! After the user // sees the explanation, try again to request the permission. &#125; else &#123; // No explanation needed, we can request the permission. ActivityCompat.requestPermissions(thisActivity, new String[]&#123;Manifest.permission.READ_CONTACTS&#125;, MY_PERMISSIONS_REQUEST_READ_CONTACTS); // MY_PERMISSIONS_REQUEST_READ_CONTACTS is an // app-defined int constant. The callback method gets the // result of the request. &#125;&#125; 注：当您的应用调用 requestPermissions()) 时，系统将向用户显示一个标准对话框。您的应用无法配置或更改此对话框。如果您需要为用户提供任何信息或解释，您应在调用 requestPermissions()) 之前进行，如解释应用为什么需要权限中所述。 处理权限请求响应当应用请求权限时，系统将向用户显示一个对话框。当用户响应时，系统将调用应用的 onRequestPermissionsResult())方法，向其传递用户响应。您的应用必须替换该方法，以了解是否已获得相应权限。回调会将您传递的相同请求代码传递给 requestPermissions())。例如，如果应用请求 READ_CONTACTS 访问权限，则它可能采用以下回调方法： 123456789101112131415161718192021222324@Overridepublic void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) &#123; switch (requestCode) &#123; case MY_PERMISSIONS_REQUEST_READ_CONTACTS: &#123; // If request is cancelled, the result arrays are empty. if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; // permission was granted, yay! Do the // contacts-related task you need to do. &#125; else &#123; // permission denied, boo! Disable the // functionality that depends on this permission. &#125; return; &#125; // other 'case' lines to check for other // permissions this app might request &#125;&#125; 系统显示的对话框说明了您的应用需要访问的权限组；它不会列出具体权限。例如，如果您请求 READ_CONTACTS 权限，系统对话框只显示您的应用需要访问设备的联系人。用户只需要为每个权限组授予一次权限。如果您的应用请求该组中的任何其他权限（已在您的应用清单中列出），系统将自动授予应用这些权限。当您请求此权限时，系统会调用您的 onRequestPermissionsResult()) 回调方法，并传递 PERMISSION_GRANTED，如果用户已通过系统对话框明确同意您的权限请求，系统将采用相同方式操作。 注：您的应用仍需要明确请求其需要的每项权限，即使用户已向应用授予该权限组中的其他权限。此外，权限分组在将来的 Android 版本中可能会发生变化。您的代码不应依赖特定权限属于或不属于相同组这种假设。 例如，假设您在应用清单中列出了 READ_CONTACTS 和 WRITE_CONTACTS。如果您请求 READ_CONTACTS 且用户授予了此权限，那么，当您请求 WRITE_CONTACTS 时，系统将立即授予您该权限，不会与用户交互。 如果用户拒绝了某项权限请求，您的应用应采取适当的操作。例如，您的应用可能显示一个对话框，解释它为什么无法执行用户已经请求但需要该权限的操作。 当系统要求用户授予权限时，用户可以选择指示系统不再要求提供该权限。这种情况下，无论应用在什么时候使用 requestPermissions()) 再次要求该权限，系统都会立即拒绝此请求。系统会调用您的 onRequestPermissionsResult()) 回调方法，并传递 PERMISSION_DENIED，如果用户再次明确拒绝了您的请求，系统将采用相同方式操作。这意味着当您调用 requestPermissions()) 时，您不能假设已经发生与用户的任何直接交互。 [ 上一页 arrow_backOverview](https://developer.android.com/guide/topics/permissions/overview?hl=zh-cn) [ 下一页 arrow_forwardApp permissions best practices](https://developer.android.com/training/permissions/usage-notes?hl=zh-cn) Content and code samples on this page are subject to the licenses described in the Content License. Java is a registered trademark of Oracle and/or its affiliates. 上次更新日期：四月 25, 2018]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F27%2FProgrammer%2FHTTP%20%E5%93%8D%E5%BA%94%E4%BB%A3%E7%A0%81-2019-01-14%2F</url>
    <content type="text"><![CDATA[HTTP 响应代码400400 是 HTTP 的状态码，主要有两种形式： 1、bad request 意思是 “错误的请求”；2、invalid hostname 意思是 “不存在的域名”。400 Bad Request 是由于明显的客户端错误（例如，格式错误的请求语法，太大的大小，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。 解决方案： 1、对照字段名称，类型保证一致性 2、检查域名3、容易忽略的情况， 400一般是被认为是客户端的错误，但是如果服务器端有，权限管理（用户登录、用户注册）、 业务管理两个子系统，通过一个网关去分别跳转， 在登录时网关负责从客户端的 token中解析出userId并传给权限管理系统，如果网关没有传参数keyusrId=即url中根本没有userId=***，而权限管理系统需要userId,则此时也会报错，如果此时还从客户端找问题，非常难找到问题。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F27%2FAndroid%2FAndroid%E4%B8%AD%20dpi%EF%BC%8C%E5%88%86%E8%BE%A8%E7%8E%87%EF%BC%8C%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8%EF%BC%8Cdp%EF%BC%8Cpx%EF%BC%8Cdip-2019-02-18%2F</url>
    <content type="text"><![CDATA[Android中 dpi，分辨率，屏幕尺寸，dp，px，dip-2019-02-18!--参考：https://www.jianshu.com/p/211cbaa5a59e-- 1.什么是屏幕尺寸、分辨率和像素密度？屏幕尺寸单位：英寸（inch） 1英寸 = 2.54厘米 目前市场上屏幕尺寸以5.5英寸为主（Android 2018年），数据由【友盟】提供。 屏幕分辨率：定义：横纵向上的像素点 （ 分辨率越高，显示的效果越好） 单位：px 1px = 1像素点 一般表达的方式，纵向像素 横向像素 = 1920 1080 目前市场上手机屏幕分辨率 还是以1920*1080像素为主 屏幕像素密度定义：指的是每英寸上的像素点 （密度越高，显示效果越好） 单位：dpi **像素密度与【屏幕尺寸】和【分辨率】有关** 下面举个“栗子” 一步4.95英寸、屏幕分辨率是1920*1080的手机，求屏幕像素密度 手机4.95英寸，指的是手机对角线的长度 因为AC=1920，BC=1080，所以AB≈2203 所以像素密度 = 2203 / 4.95 ≈ 445 为什么我们要用android开发的时候不用px做为单位？px（像素）构成图像的最小单位 dp 、dip密度无关像素 【注意，dip和dpi不一样】 如果在160dpi（像素密度为160），那么 1dip = 1px 在240dpi（像素密度为240），那么 1.5dip = 1px （后面会解释，别着急） 举个“栗子” 在2部手机中 A手机 分辨率为 480*320，像素密度为 160DPI B手机 分辨率为 800*480，像素密度为 240DPI A手机 B手机 如果我们图片要在A手机宽度铺满全屏显示的话，我们就得设置图片宽度为320px 我们要B手机宽度铺满全屏显示，需要设置多少？得设置480px。 那么问题来了，android手机那么多，分辨率并不是固定的（参考楼上分辨率数据），不像iPhone，屏幕的分辨率是固定的。我们想要图片在每部手机显示都是横向铺满的，设置px的话明显有问题。 所以，我们开发的时候单位一般设置为dp、dip 如果我们图片设置320dp，在480*320上，1dp=1px，所以图片是铺满的 在800480手机上，1px = 1.5dp，所以320dp = 320dp 1.5 = 480dp，所以图片也是铺满的 可能到这里小伙伴们头脑没转过来，为什么1px在不同分辨率手机上，等于的dp是不同的呢？ 因为手机的像素密度不同啊！ 上面说过dp、dip叫做密度无关像素，你可以这么理解，dp和dip存在的意义，是和像素密度没有关系的。我使用dp作为单位设置控件，不管你什么屏幕大小，多大的dpi，显示的效果始终保持一致。就是专门用于不同手机屏幕分辨率，我却能都适应。至于160dpi里1dp=1px，480dpi里1dp=1.5px，为什么这么设置呢？因为人家google就这么定义的。没必要深究 px和dp的换算公式：px = dp * (dpi / 160) sp定义：根据字体首选项进行缩放 sp绝大部分都是用来设置文字大小的大小. google开发指导手册上推荐我们设置12sp以上大小的单位，不要用12sp以下，以为用户可能看不清。推荐使用大小有12sp、14sp、18sp和22sp作为我们首选的字体大小。 字体设置的时候 不能有 小数和奇数。因为字体放缩的时候可能对精度的丢失 ==写法好像有错误== 以上写法有误，如果屏幕密度较高，密度无关像素会相应扩展至整个屏幕。1dp在设备屏幕上总是等于1/160英寸。使用dp的好处是，无论屏幕密度如何，总能获得同样的尺寸。 《Android开发权威指南》1dp = 1/160 英寸, !--参考：https://www.jianshu.com/p/a585841282a8-- 1.先来看几个概念 分辨率，像 1920x1080 屏幕像素密度：屏幕每英寸所包含的像素数 dpi：（Dots Per Inch，每英寸点数）一种度量单位 怎么根据分辨率和屏幕尺寸计算屏幕密度？ 计算屏幕密度.png 那440dpi在android中是什么样的概念呢？ 谷歌官方文档中对于密度的分类.png 属于xxhdpi这一分类 ，那么其运行时加载的图片也是xxhdpi文件夹下的。 2.接下来看px与dp还有dip的关系 dp其实就是dip：设备独立像素（又称设备无关像素 Device Independent Pixels 、密度独立性 Density ndependent或设备独立像素，简称DIP或DP）。 dp也是谷歌推荐的android开发中使用单位。 px：像素 一般UI拿过来的图就是px标注的，然后会告诉你做图时所用的尺寸是多大的，如1334x750，4.7寸的屏幕 image.png 我们该怎么把px转为dp写在android的布局文件中呢？ 先计算UI所给图纸的密度，1334x1334+750x750=2342056 2342056 开根号大概为 1530 1530/4.7 = 325 dpi 325/160 = 2.03 （160相当于一个标准dpi，是google给定的值，我们所计算的dpi都会与其进行比较） 如图上一个控件是高80px，那 80/2.03 大概40dp，我们一般就在布局文件设置40dp]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F27%2FAndroid%2FAndroid%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%862019-02-12%2F</url>
    <content type="text"><![CDATA[Android基础知识tools:listitem 可以预览RecyclerView加入Item Layout后的效果1234567&lt;android.support.v7.widget.RecyclerView xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/rv_content" style="@style/MatchMatch" android:background="#ccc" android:scrollbars="none" tools:listitem="@layout/item_normal"/&gt; EditText 中获取焦点并不能触发 addTextChangedListener 监听中的三个方法， 改变字符可以，增、删、删增、可以触发。 gradle123456789101112 buildTypes &#123; release &#123; //zip优化 zipAlignEnabled true// 参考 https://stackoverflow.com/questions/52310841/removing-unused-resources-requires-unused-code-shrinking-to-be-turned-on //移除无用的resource文件 shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.txt' &#125; &#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F27%2FAndroid%2Fandroid%20studio%E4%BF%AE%E6%94%B9%E9%A1%B9%E7%9B%AE%E5%90%8D-2018-03-21%2F</url>
    <content type="text"><![CDATA[android studio修改项目名(project name)在使用Android studio 开发，想要修改我们的工程名或者包名，却感到无从下手该怎么办呢？ 一般修改工程名都会： 选中工程右键 &gt; refactor &gt; rename 填好名字确定后被提示 ”can’t rename root module” 因为Android Studio只能修改根目录内的所有文件。 修改Project工程名解决办法: 1.首先关闭Android studio，然后找到工程所在的文件夹，把工程文件夹重命名为想要的名字。如图： 2.用Android studio重新打开android_service这个工程。如图：改为 以下演示的都是，修改后的， 3.修改 .iml文件名为terminal-android-guizhou.iml 和这个文件里面的 1&lt;module external.linked.project.id="terminal-android-guizhou" 如图： 4 导入到Android Studio 5.目录.idea/modules.xml里面的fileurl导入工程时已经自动改正，可以查看一下。如图： 6．Run一下工程Ok了！ 修改Package包名解决办法:在 Project工具栏点击这里 出现下图将Compact Empty Middle前面的勾去掉，包的层级将会改变。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F27%2FAndroid%2FAndroid%20Error%202019-02-13%2F</url>
    <content type="text"><![CDATA[Android ErrorAndroid androidx今天使用rxlifecycle时，遇到123Manifest merger failed : Attribute application@appComponentFactory value=(android.support.v4.app.CoreComponentFactory) from [com.android.support:support-compat:28.0.0-alpha3] AndroidManifest.xml:22:18-91 is also present at [androidx.core:core:1.0.0-alpha3] AndroidManifest.xml:22:18-86 value=(androidx.core.app.CoreComponentFactory). Suggestion: add 'tools:replace="android:appComponentFactory"' to &lt;application&gt; element at AndroidManifest.xml:5:5-19:19 to override. 查看 com.trello.rxlifecycle3的releases信息 V3.0.0 dlew 发布了这个 on 26 Oct 2018 · 自本次发布以来，有 4次提交要掌握 ＃285：更新了com.trello.rxlifecycle3的基础包 ＃284：弃用rxlifecycle-navi ＃283：升级到AndroidX ==原因是== 从v28开始, android的support库将会进行改进, 28.0.0将会是support库的终结版本. 未来新的特性和改进都会进入Androidx包。所以 ==support和Androidx冲突了==， 解决方案 整个项目完全升级到 androidx， android studio 提供了一个按钮Migrate to Androidx，可以迁移到Androidx,前提是使用android 28 退而求其次，使用低版本的RxLifecycle（没有升级到升级到AndroidX的）因为项目时间紧急，所以我暂时选择使用低版本的RxLifecycle。 魅族手机遇到的 application terminatedMeizu M6 Note Android 7.1.2. API 25 run能看到的信息1234$ adb shell am start -n "com.ctitc.futureterminal/com.ctitc.futureterminal.ui.activity.SplashActivity" -a android.intent.action.MAIN -c android.intent.category.LAUNCHERClient not ready yet..Waiting for process to come onlineConnected to process 7016 on device xiaomi-mi_5s-88a9c127Application terminated. 因为看不到logcat的日志，所以无法定位到问题的根源，所以第一步是让logcat输出日志。1.搜索 魅族 logcat 找到打开【设置】中的【开发者选项】，页面底部找到【性能优化】，打开【高级日志输出】，勾选【全部允许】即可2.定位到问题1234Process: com.ctitc.futureterminal, PID: 14552java.lang.NullPointerException: Attempt to invoke virtual method 'int android.text.Layout.getLineForOffset(int)' on a null object reference at android.widget.Editor.updateCursorPositionMz(Editor.java:7836) at android.widget.Editor.updateCursorsPositions(Editor.java:1963) 3.上网搜索 https://github.com/android-in-china/Compatibility/issues/11 https://stackoverflow.com/questions/51891415/nullpointerexception-on-meizu-devices-in-editor-updatecursorpositionmz 因为当时魅族手机不输出 logcat日志，不知道问题出在哪儿，从不同的日期的commit中新建branch 然后测试哪两个相邻日期的branch一个是闪退的一个是不闪退的花费了大量的时间，切记对于不输出logcat的机型，先解决log输出再找问题。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F27%2FAndroid%2FAndroid%20View%20%E5%88%86%E6%9E%902019-02-20%2F</url>
    <content type="text"><![CDATA[Android View 分析2019-02-2012345678910111213141516171819202122/** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. * 测量规范模式：父级没有对孩子施加任何约束。它可以是它想要的任何尺寸。 * */ public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The parent has determined an exact size * for the child. The child is going to be given those bounds regardless * of how big it wants to be. * 测量规范模式：父母已确定孩子的确切大小。无论孩子想要多大，孩子都将被赋予这些界限。 */ public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; /** * Measure specification mode: The child can be as large as it wants up * to the specified size. * 测量规范模式：子项可以达到指定大小所需的大小。 */ public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; android 中使用代码获取A控件的高度，并把此值设置到B控件 1234567891011// 获取et_sms_code高度 et_sms_code.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; et_sms_code.getViewTreeObserver().removeOnGlobalLayoutListener(this); // 把 et_sms_code的高度传递给 btn_request_sms_code params.height = et_sms_code.getHeight(); //height is ready // 给btn_request_sms_code设置高度， btn_request_sms_code.setLayoutParams(params); &#125; &#125;); 123456789ViewGroup.LayoutParams params = btn_request_sms_code.getLayoutParams(); et_sms_code.addOnLayoutChangeListener(new View.OnLayoutChangeListener() &#123; @Override public void onLayoutChange(View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) &#123; et_sms_code.removeOnLayoutChangeListener(this); params.height = et_sms_code.getHeight() - 10; btn_request_sms_code.setLayoutParams(params); &#125; &#125;);]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F27%2FAndroid%2FAndroid%20Profiler%E5%88%86%E4%B8%BA%E4%B8%89%E5%A4%A7%E6%A8%A1%E5%9D%97%EF%BC%9A%20cpu%E3%80%81%E5%86%85%E5%AD%98%20%E3%80%81%E7%BD%91%E7%BB%9C%E3%80%82%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%A8%E4%B8%8A%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%9C%89%E8%AE%B2%E5%88%B0%E3%80%82%E8%BF%99%E9%87%8C%E8%AF%A6%E7%BB%86%E8%AF%B4%E4%B8%80%E4%B8%8B-2018-02-28%2F</url>
    <content type="text"><![CDATA[Android Profiler分为三大模块： cpu、内存 、网络。基本的使用在上一篇文章有讲到。这里详细说一下一、 CPU分析器CPU ProfilerCPU分析器可帮助您实时检查应用程序的CPU使用情况和线程活动，并记录方法跟踪，以便您可以优化和调试应用程序的代码。 要打开CPU Profiler，请按照下列步骤操作： 点击 View &gt; Tool Windows &gt; Android Profiler (还可以点击工具栏的). 从Android Profiler工具栏中选择要配置的设备和应用程序进程(如果您已通过USB连接设备但未看到它，请确保已启用USB调试) 单击CPU时间轴中的任意位置打开CPU Profiler。 1.1 为什么要优化CPU的使用优化CPU使用率有许多优点，例如提供更快更流畅的用户体验，并保持设备电池寿命。它还可以帮助您的应用程序在各种较新旧的设备上运行良好，您可以使用CPU分析器在与应用程序交互时监视CPU使用情况和线程活动，但是，有关应用程序执行代码的更详细信息，应记录并检查方法跟踪。 对于应用程序进程中的每个线程，您可以找到在一段时间内执行哪些方法以及每个方法在执行期间消耗的CPU资源。您还可以使用方法跟踪来识别调用者和被调用者，调用者是一种调用另一种方法的方法，被调用方是另一种方法调用的方法。您可以使用此信息来确定哪些方法太频繁地调用特定资源繁重的任务，就可以尝试优化应用程序的代码以避免不必要的工作。 如果要收集详细的系统级数据，帮助您检查本地系统进程并解决由丢帧引起的UI jank，则应使用Systrace。或者，如果要导出使用Debug捕获的.trace文件，则应使用Traceview 1.2 CPU Profiler概述当您打开CPU分析器时，它会立即开始显示应用程序的CPU使用情况和线程活动。你会看到类似于下图的内容 如上图所示，CPU Profiler的默认视图包括以下内容： ①Event timeline： 显示您的应用程序在其生命周期中转换不同状态的活动，并指示用户与设备的交互，包括屏幕旋转事件。要了解有关事件时间轴的更多信息，包括如何启用它，请阅读我上一篇文章说到的启用高级分析 ②CPU timeline: 显示您的应用程序的实时CPU使用率（占总可用CPU的百分比）以及应用程序使用的线程总数，时间轴还显示其他进程的CPU使用情况（如系统进程或其他应用程序），所以您可以将其与应用程序的使用情况进行比较。您可以通过沿着时间轴的水平轴移动鼠标来检查历史CPU使用率数据。 ③Thread activity timeline: 列出属于您的应用程序进程的每个线程，并使用不同的颜色在时间轴上指示其活动。记录方法跟踪后，可以从此时间轴中选择一个线程，在跟踪窗格中检查其数据。 绿色: 线程处于活动状态或准备好使用CPU。也就是说，它处于”运行”或”可运行”状态。 黄色： 线程处于活动状态，但是在完成其工作之前，它正在等待I / O操作（如文件或网络I / O）。 灰色： 线程正在睡眠，不会消耗任何CPU时间，当线程需要访问尚未可用的资源时，有时会发生这种情况。要么线程进入自愿性睡眠，要么内核使线程休眠，直到所需的资源可用。 ④Tracing type：允许您选择以下选项之一来确定分析器如何记录方法跟踪。 Sampled： 在应用程序执行期间，您可以频繁地捕获应用程序的调用堆栈。profiler将捕获的数据集进行比较，以获取关于应用程序代码执行的时间和资源使用信息。基于sampled跟踪的一个固有问题是，如果您的应用程序在捕获调用堆栈并在下一次捕获之前退出该方法，那么该方法调用不会被分析器记录。如果您对具有这样短生命周期的跟踪方法感兴趣，您应该使用工具跟踪。 Instrumented： 在您的应用程序运行时记录每个方法调用的开始和结束时的时间戳。收集时间戳并与生成方法跟踪数据进行比较，包括时间信息和CPU使用。请注意，对每种方法进行检测的开销会影响运行时性能，并可能影响性能分析，因此对于具有相对较短的生命周期的方法来说，这更加值得注意。此外，如果您的应用程序在短时间内执行大量的方法，profiler可能很快超过它的文件大小限制，进而不能记录任何进一步的跟踪数据。 ⑤Record button：开始和停止记录方法跟踪。要了解更多信息，请继续看下去 提示：profiler还报告了Android Studio和Android平台在你的应用程序过程中添加的线程的CPU使用情况，如JDWP、Profile Saver、Studio:VMStats、Studio:Perfa和Studio:Heartbeat(尽管，在线程活动时间线中显示的确切名称可能会有所不同)。这意味着您的应用程序在CPU时间轴上的CPU使用率也会报告这些线程使用的CPU时间。您可以在线程活动时间表中看到这些线程，并监视它们的活动。(但是，由于profiler线程执行native代码，因此无法为它们记录方法跟踪数据。)Android Studio会报告这些数据，这样你就可以很容易地识别出线程活动和CPU使用实际上是由你的应用程序代码引起的。 1.3 记录和检查方法跟踪要开始记录方法跟踪，从下拉菜单中选择Sampled或Instrumented类型，然后单击Record开始进行记录，完成后点击Stop recording停止记录。profiler自动选择记录的时间帧，并在方法跟踪窗格中显示它的跟踪信息，如下图所示。如果要检查不同线程的方法跟踪，只需从线程活动时间轴中选择它。 ① Selected time frame: 在跟踪窗格中检查的记录时间框架的部分。当您第一次记录一个方法跟踪时，CPU分析器将自动选择您在CPU时间线中记录的整个长度。如果要检查仅记录的时间帧的一部分的方法跟踪数据，您可以单击并拖动高亮显示区域的边缘来修改它的长度。 ②Timestamp： 表示记录方法跟踪的开始和结束时间(相对于profiler开始从设备收集CPU使用信息时)。你可以点击时间戳来自动选择整个记录作为你选定的时间框架——如果你有多个你想要转换的记录，这是非常有用的。 ③Trace pane：显示您所选择的时间框架和线程的方法跟踪数据。仅当您记录至少一个方法跟踪后，此窗格才会显示。在此窗格中，您可以选择如何查看每个堆栈跟踪（使用跟踪选项卡）以及如何测量执行时间（使用时间参考下拉菜单）。 ④: 选择显示为Top Down tree, Bottom Up tree, Call Chart, or Flame Chart这些类型的图。您可以在下面的部分中了解有关每个跟踪窗格选项卡的更多信息。 从下拉菜单中选择以下选项之一，以确定如何测量每个方法调用的时序信息： Wall clock time： 表示实际经过时间。 Thread time：计时信息表示实际的消耗时间减去不消耗CPU资源的那段时间的任何部分。对于任何给定的方法，它的线程时间总是小于或等于它的时钟时间。使用线程时间让您更好地了解给定方法所消耗的线程实际CPU使用量 1.3.1 使用Call Chart选项卡检查跟踪Call Chart选项卡提供一个方法跟踪的图形表示，其中一个方法调用(或调用者)的周期和时间在水平轴上表示，而它的callees则显示在垂直轴上。对系统api的方法调用以橙色显示，调用您的应用程序自己的方法以绿色显示，方法调用第三方api(包括java语言api)以蓝色显示。下面的图显示了一个示例调用图，并说明了给定方法的自时间、子时间和总时间的概念。关于如何使用自上而下和自下而上检查痕迹的部分，请继续看下去 提示： 如果想要跳转到方法的源代码，请右键单击该方法，然后选择Jump to Source。这可以从任何窗格选项卡工作。 1.3.2 使用火焰图表(Flame Chart)选项卡检查痕迹火焰图选项卡提供了一个反向调用图表，聚合了相同的调用堆栈。也就是说，收集相同的调用序列的相同方法被收集并表示为火焰图中的一个较长的栏(而不是将它们显示为多个更短的条，如调用图所示)。这样就更容易看出哪些方法消耗的时间最多。然而，这也意味着横轴不再表示时间轴，相反，它表示每个方法执行的相对时间。 为了帮助说明这个概念，考虑下面图4中的调用图表。注意，方法D对B(B1、B2和B3)进行多次调用，其中一些调用B对C(C1和C3)进行调用。 因为B1、B2和B3共享相同的序列调用者(A→D→B)聚合,如下所示。同样,C1和C3聚合,因为它们共享相同的序列调用者(A→D→B→C)注意不包括C2,因为它有不同的调用者序列(A→D→C)。 聚合方法调用用于创建flame 图，如下图所示。注意，对于任何给定的方法调用，在flame图中，消耗最多CPU时间的callees首先出现。 1.3.3 使用自上而下和自下而上检查Top Down选项卡显示方法调用的列表，扩展方法节点显示其callees。下图显示了上面的图3中调用图的顶部向下图。图中的每个箭头都是从调用者到callee。 下图所示，在顶部的down选项卡中扩展方法A的节点将显示它的callees、方法B和D。在此之后，扩展方法D的节点将暴露它的callees、方法B和C，等等。与火焰图选项卡类似，顶部向下的树聚合跟踪信息，用于共享相同调用堆栈的相同方法。也就是说，火焰图标签提供了顶部下标签的图形表示。 Top Down选项卡提供以下信息，以帮助描述在每个方法调用上花费的CPU时间(在选定的时间段内，时间也代表线程总时间的百分比): Self:方法调用用于执行自己的代码而不是它的callees的时间量，如上面的图3所示。 Children：方法调用花费的时间用于执行其被调用者，而不是其自己的代码，如图3中的方法D所示。 Total：方法的Self和Children的时间的总和。这表示应用程序执行方法调用的总时间量，如图3所示的方法D。 Bottom Up选项卡显示一个方法调用列表，扩展方法的节点显示其调用者。使用上图所示的例子中,下图提供了一个自下而上方法C .在自下而上的树中打开方法C的节点，显示每个独特的调用者,方法B和d .注意,虽然B两次调用C,B当扩大节点只出现一次自下而上方法C的树。再此之后，展开节点B显示其调用者方法A和D. Bottom Up选项卡对于那些消耗最多(或最少)CPU时间的方法的排序方法很有用。您可以检查每个节点，以确定哪些调用者在调用这些方法上花费最多的CPU时间。与上面的树相比，底部树中每个方法的定时信息都是在每棵树的顶部(顶部节点)的方法。在记录期间，CPU时间也被表示为线程总时间的百分比。下表有助于解释如何解释顶级节点及其调用方方法(子节点)的定时信息。 名称 Self Children Total 自下而上树顶部的方法（顶层节点） 表示用于执行其自己的代码而不是其callees的方法的总时间。与上面的树相比，这个时间信息表示在记录期间对该方法的所有调用的总和。 表示用于执行callees而不是自己的代码的总时间。与上面的树相比，这个时间信息表示在记录期间对该方法的callees调用的所有调用的总和。 Self时间和Children的时间总和 Caller 方法 (子节点) 表示调用者调用callee的总时间。使用上图中的底向上树作为例子，方法B的自我时间将等于每个方法C调用时的Self时间的总和。 表示调用者调用的callee的总子时间。在上图中使用底部向上的树为例，方法B的孩子时间将等于每个方法C调用时执行方法C的总和。 Self时间和Children的时间总和 对于给定的记录，当profiler达到文件大小限制时，Android Studio停止收集新数据(但是这并没有停止记录)。这种情况在执行检测跟踪时通常会发生得更快，因为这种类型的跟踪会在较短的时间内收集更多的数据，而不是取样跟踪。如果将检查时间帧扩展到在到达限制后发生的记录期间，那么跟踪窗格中的计时数据不会发生变化(因为没有可用的新数据)。此外，当您只选择没有可用数据的记录的部分时，跟踪窗格将显示NaN用于计时信息。 二、 内存分析器memory profiler内存分析器是Android Profiler中的一个组件，它可以帮助您识别内存泄漏和内存溢出，从而导致存根、冻结甚至应用程序崩溃。它显示了应用程序内存使用的实时图，让您捕获堆转储、强制垃圾收集和跟踪内存分配。 要打开内存分析器和cpu检查器一样，就在隔壁。 2.1 为什么使用内存分析器Android提供了一个托管内存环境——当它确定你的应用不再使用某些对象时，垃圾收集器会将未使用的内存释放回堆。在所有Android版本的某个点上，系统必须短暂地暂停代码。大多数时候，停顿是不可察觉的。但是，如果你的应用程序分配内存的速度快于系统收集的速度，你的应用程序可能会被延迟，而收集器释放了足够的内存来满足你的分配。延迟可能会导致应用程序跳过帧并导致明显的慢速。 即使你的应用程序没有表现出缓慢，如果它泄露了内存，它仍然可以保留那个内存，即使它在后台。通过强制不必要的垃圾收集事件，这种行为可以降低系统内存性能的其他部分。最终，系统不得不杀死你的应用程序来回收内存。然后当用户返回到你的应用程序时，它必须重新启动。 为了帮助防止这些问题，您应该使用内存分析器来执行以下操作： 在可能导致性能问题的时间轴中寻找不良的内存分配模式 Dump Java堆，以便在任何时间查看哪些对象正在使用内存。长时间的堆转储可以帮助识别内存泄漏。 在正常和极端的用户交互过程中记录内存分配，以精确地确定您的代码在短时间内分配的对象或分配被泄漏的对象。 有关可以减少应用程序内存使用的编程实践的信息，请参阅管理应用程序的内存。 2.2 内存分析器概述 如上图所示，内存分析器的默认视图包括以下内容： ① 强制执行垃圾收集事件的按钮。 ② 捕获堆转储的按钮。 ③ 记录内存分配的按钮。 ④ 放大时间线的按钮。 ⑤ 跳转到实时内存数据的按钮。 ⑥ 事件时间线显示活动状态、用户输入事件和屏幕旋转事件。 ⑦ 内存使用时间表，其中包括以下内容： 每个内存类别使用多少内存的堆栈图，如左边的y轴和顶部的颜色键所示。 虚线表示已分配对象的数量，如右侧y轴所示。 每个垃圾收集事件的图标。 但是，默认情况下并不是所有的分析数据都可见。如果您看到一条消息，说“高级分析不可用于所选进程”，则需要启用高级分析以查看以下内容： 活动时间表 分配对象的数量 垃圾收集事件 提示： 与之前的Android监控工具相比，新的内存分析器记录了你的内存使用情况，所以看起来你的内存使用量会更高。内存分析器监视一些额外的类别，这些类别增加了总数，但如果您只关心Java堆内存，那么“Java”的数字应该与上一个Android监视器的值类似。新的号码记录了从Zygote分派到应用程序的Java堆中的所有物理内存页面，这准确表示您的应用程序实际使用多少物理内存。 2.3 记录内存分配查看堆转储时，查看分配了多少内存的快照很有用，它不会显示如何分配内存。为此，您需要记录内存分配。完成记录会话后，您可以看到以下记录的持续时间： 分配了哪些对象以及它们使用了多少空间。 在堆栈跟踪中分配每个对象的位置，其中包括线程。 要查看应用程序的内存分配，请单击内存分析器工具栏中的Record memory allocations。当它记录时，与你的应用程序进行交互，以引起内存溢出或内存泄漏。完成后，单击Stop recording。 分配的对象列表出现在时间轴下面，按类名称分组，按堆计数排序，如上图所示。 分配跟踪器最多记录65535个分配。如果您的记录超出此限制，则只有最近65535个分配将保存在该记录中。 要检查分配记录，请按照下列步骤操作： 浏览列表以查找具有非常大的堆计数且可能泄漏的对象，要帮助查找已知类，请单击类名列标题按字母顺序排序。然后单击一个类名，Instance View 窗格就会显示在右侧，显示该类的每个实例，如下图所示。 在Instance View窗格中，单击一个实例。Call Stack选项卡显示在下面，显示了哪个实例被分配在哪个线程中。 在Call Stack选项卡中，单击任意行可以在编辑器中跳转到该代码。 默认情况下，列表是按类名排列的。在列表的顶部，您可以使用右下拉菜单在列表之间切换: Arrange by class： 根据类名分配。 Arrange by package：根据包名分配。 Arrange by callstack: 根据调用堆栈排序 2.4 捕获堆转储堆转储显示在捕获堆转储时应用程序正在使用内存的对象。特别是在扩展用户会话之后，堆转储可以通过显示仍然在内存中的对象来帮助识别内存泄漏。捕获堆转储后，可以查看以下内容: 您的应用程序分配了哪些类型的对象，以及每个对象的数量。 每个对象使用多少内存 每个对象的引用被保留在你的代码中。 调用堆栈，用于分配对象的位置（只有在记录分配时捕获堆转储）。 要捕获堆转储，单击Memory-Profiler工具栏中的dump Java堆。在转储堆时，Java内存的数量可能会暂时增加。这是正常的，因为堆转储发生在与应用程序相同的进程中，需要一些内存来收集数据。 堆转储出现在内存时间轴下方，显示堆中的所有类类型，如上图所示。 要检查你的堆，请按照下列步骤操作： 浏览列表以查找具有异常大堆计数的对象，因为它可能会被泄露。为了帮助查找已知类，请单击类名列标题以按字母顺序排序。然后单击类名。实例视图窗格出现在右边，显示该类的每个实例，如下图所示。 在Instance View窗格中，单击一个实例。 References选项卡显示在下面，显示对该对象的所有引用。或者单击实例名称旁边的箭头以查看其所有字段，然后单击字段名称以查看其所有引用。如果要查看某个字段的实例详细信息，请右键单击该字段，然后选择Go to Instance。 在References选项卡中，如果识别可能是内存泄漏的引用，请右键单击它，然后选择Go to Instance.。这将从堆转储中选择相应的实例，显示您自己的实例数据。 默认情况下，堆转储不会显示每个已分配对象的堆栈跟踪。要获取堆栈跟踪，您必须在单击转储Java堆之前开始记录内存分配。如果您这样做，您可以在实例视图中选择一个实例，并在References选项卡旁边看到Call Stack选项卡，如下图所示。但是，在开始记录分配之前，可能已经分配了一些对象，因此这些对象无法使用调用堆栈。包含一个调用堆栈的实例在图标上有一个stack标记。 在classes列表中，您可以看到以下信息： Heap Count: 堆中的实例数。 Shallow Size: 此堆中所有实例的总大小（以字节为单位）。 Retained Size: 这个类的所有实例(以字节为单位)保留的内存总大小。 在类列表的顶部，可以使用左下拉列表在以下堆转储之间切换: Default heap: 当系统没有指定堆时。 App heap: 应用程序分配内存的主堆。 Image heap: 系统引导映像，包含在引导期间预加载的类。这里的分配保证永远不会移动或离开。 Zygote heap: Android系统中分发应用程序进程的写时复制堆 默认情况下，列表按保留大小列排序。您可以单击任何列标题来更改列表的排序方式。 在Instance View中，每个实例包括以下内容： Depth：从任何GC根到所选实例的跳数最短。 Shallow Size：此实例的大小。 Retained Size：此实例支配的内存大小（根据支配者树)。 三、 网络分析器(Network Profiler)网络分析器在时间轴上显示实时网络活动，显示发送和接收的数据，以及当前连接的数量。这让您可以检查应用程序如何和何时传输数据，并适当地优化底层代码。 打开面板的步骤和上面的几乎一致。 3.1 为什么要使用网络分析器当应用程序向网络发出请求时，设备必须使用耗电的移动或WiFi无线电来发送和接收数据包。接收器不仅使用电力传输数据，而且还使用额外的电源打开和保持唤醒。 使用网络分析器，您可以查找频繁的、短的网络活动高峰，这意味着您的应用程序要求网络经常打开，或者长时间保持唤醒，以处理许多短的请求。这一模式表明，您可以通过批处理网络请求来优化应用程序，以改善电池性能，从而减少网络必须打开或接收数据的次数。这也使得网络可以切换到低功率模式，以节省电池的时间间隔。 有关优化应用程序网络活动的技术的更多信息，请参阅 Reducing Network Battery Drain。 3.2 网络分析器概述在窗口的顶部，您可以看到事件时间线和①无线电电源状态(high/low)和wi-fi。在时间轴上，您可以单击和拖动来选择②时间轴的一部分来检查流量。下面的③窗口显示在时间轴的选定部分中发送和接收的文件，包括文件名、大小、类型、状态和时间。您可以通过单击任何列标题来对列表进行排序。您还可以看到时间线所选部分的详细分解，显示每个文件被发送或接收的时间。 单击连接的名称，查看所选文件发送或接收的详细信息。单击④选项卡查看响应数据、头信息或调用堆栈。 提示：您必须启用高级概要分析来选择时间轴的一部分来检查，查看发送和接收的文件的列表，或者查看所选文件发送或接收的详细信息。为了启用高级分析，请查看上一篇文章 3.3 网络连接疑难解答如果网络分析器检测到流量值，但无法识别任何支持的网络请求。您将收到以下错误消息：”Network Profiling Data Unavailable: There is no information for the network traffic you’ve selected.” 目前，网络分析器只支持HttpURLConnection和OkHttp库。如果您的应用程序使用另一个网络连接库，那么您可能无法在网络分析器中查看您的网络活动。如果您已经收到了这个错误消息，但是您的应用程序确实使用HttpURLConnection或OkHttp，请报告错误，以便我们可以调查这个问题。 转载：http://blog.csdn.net/niubitianping/article/details/72617864]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F24%2FVersionControl%2Fgit%20gui%20tower%20compare%20tow%20commit%20diff2019-02-24%2F</url>
    <content type="text"><![CDATA[TowerComparing Branches &amp; Revisions Sometimes, you’ll want to know how two branches (or even two arbitrary revisions) differ in detail. In any case, please make sure you have configured your favorite external diff tool in Tower’s preferences window. Comparing Branches选择两个brache 然后右击 Comparing Revisions (compare commits) select both commits you want to compare and click the Diff button on the right.选择两个要需要比较的 commit 然后点击右侧的 compare。参考：https://www.git-tower.com/help/mac/commit-history/compare-branches-revisions right-click a commit and select Compare with Revision…. In the following dialog, you can then enter the commit hash of the other commit. 把需要比较的 version 的 commit hash 粘贴到 To Revision框中。 git 和 svn 不同 没有版本号的概念，通过 commit hash区分不同的 version。 SorceTreeUse ⌘ (OSX) or CTRL (Windows and Linux) and choose any two commits you like in log view. It does not matter what branch the commits belong to. As a result you will see something like… Displaying all changes between f03a18bf0370c62bb5fb5c6350589ad8def13aea and 4a4b176b852e7c8e83fffe94ea263042c59f0548 …down below.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F20%2FAndroid%2Fandroid%20view2019-02-20%2F</url>
    <content type="text"><![CDATA[android Viewdip是Density independent pixel的缩写，也就是独立的像素密度的意思，dip是基于屏幕密度的抽象单位，与设备无关，用于说明与密度无关的尺寸和位置。它是相对于一个160dpi的屏幕来说的，因此1dip对应160dpi屏幕上的1px。 dip指的是一种独立像素的表示方式，它的计算是在dpi的基础之上的，也就是说，我们只有在知道dpi是多少之后，才能够根据不同的dpi，来精确计算我们需要的dip。 dpi是一种密度单位，是dot per inch的缩写，也就是每英寸多少个像素点的意思。比如说，我们有一个480*800分辨率的手机，屏幕的物理尺寸是3英寸*5英寸，那么我们就可以计算出这个手机的是480/3＝160dpi，是属于低分辨率的，那么在这种分辨率下面， px（像素） 1dip(dp) = 1/160 in(英寸) 固定 1dpi = 1 px/in （像素/英寸， 即一英寸上的像素个数，就是像素密度） 160dpi = 160/1 （px/in) (一英寸上有160个像素点) 此时1dip 相当于多少个像素？也就是问1/160英寸上有多少个像素点， 1dip = 1/160 160 = 1px; 也就是说，当我们在这种分辨率的手机下，控件的宽度和长度就和设计图一样大小就可以，一个dip对应一个px。但是，如果还是相同的分辨率，换成了2英寸x3.3英寸呢？那么我们就可以先算出手机的密度是480/2=240dpi，是属于高分辨率的，那么在这种分辨率下面，一个dip就相当多少个像素点？ 1dpi = 1/160 240 = 1.5 px ,即1/160英寸 乘以 每英寸上有240个像素点，就是1.5px.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F14%2FAndroid%2FRxJava%E7%9B%B8%E5%85%B3%E5%8D%9A%E6%96%872019-02-14%2F</url>
    <content type="text"><![CDATA[RxJava 相关博文 八个层面比较 Java 8, RxJava, Reactor Backpressure 翻译为回压更准确，更容易理解。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F12%2FIOS%E5%BC%80%E5%8F%912019-02-12%2F</url>
    <content type="text"><![CDATA[# 更新Pod ZBarSDK 没用pod传上去12cd ios项目路径pod update 样例123456789101112131415161718192021222324252627282930bogon:future-terminal-ios ctitc$ pod updateUpdate all podsUpdating local specs repositories $ /usr/bin/git -C /Users/ctitc/.cocoapods/repos/master fetch origin --progress remote: Enumerating objects: 63096, done. remote: Counting objects: 100% (63096/63096), done. remote: Compressing objects: 100% (30/30), done. error: RPC failed; curl 18 transfer closed with outstanding read data remaining fatal: The remote end hung up unexpectedly fatal: early EOF fatal: index-pack failed[!] CocoaPods was not able to update the `master` repo. If this is an unexpected issue and persists you can inspect it running `pod repo update --verbose`bogon:future-terminal-ios ctitc$ pod updateUpdate all podsUpdating local specs repositories $ /usr/bin/git -C /Users/ctitc/.cocoapods/repos/master fetch origin --progress remote: Enumerating objects: 63096, done. remote: Counting objects: 100% (63096/63096), done. remote: Compressing objects: 100% (30/30), done. remote: Total 244951 (delta 63068), reused 63079 (delta 63065), pack-reused 181855 Receiving objects: 100% (244951/244951), 27.45 MiB | 134.00 KiB/s, done. Resolving deltas: 100% (166785/166785), completed with 8472 local objects. From https://github.com/CocoaPods/Specs 0d0a66f88d7..9d245ec95f3 master -&gt; origin/master * [new branch] cdn_scripts -&gt; origin/cdn_scripts $ /usr/bin/git -C /Users/ctitc/.cocoapods/repos/master rev-parse --abbrev-ref HEAD master $ /usr/bin/git -C /Users/ctitc/.cocoapods/repos/master reset --hard origin/master 参考：https://www.jianshu.com/p/97189e71efd9 如果pod install/update 后clean 还无法解决，那么点击Afuture-terminal-ios.Xcworkspace文件打开再run一下试试]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F12%2FAndroid%2FRxJava-2019-01-24%2F</url>
    <content type="text"><![CDATA[RxJavaRxJava 错误操作onErrorReturn在错误处结束，不会执行onError onErrorResumeNext在错误处继续新的 Observable，不会执行onError onExceptionResumeNext如果捕捉到的异常是 Exception对象，则效果和onErrorResumeNext一样，如果捕捉到的不是Exception对象，则onExceptionResumeNext不会起任何作用，相当于没有添加次操作符。 retryretry重试几次， retryWhenretryWhen Transformers简介聪明的同学可能已经意识到了这个问题，但是RxJava早已提供了一种解决方案：Transformer（译者注：有转换器意思），一般情况下可以通过使用操作符Observable.compose())来实现。 compose.compose(new HandleErrTransformer()) 123456789101112/** project RxEasyHttp * &lt;p&gt;描述：错误转换Transformer&lt;/p&gt; * 作者： zhouyou&lt;br&gt; * 日期： 2017/5/15 17:09 &lt;br&gt; * 版本： v1.0&lt;br&gt; */public class HandleErrTransformer&lt;T&gt; implements ObservableTransformer&lt;T, T&gt; &#123; @Override public ObservableSource&lt;T&gt; apply(@NonNull Observable&lt;T&gt; upstream) &#123; return upstream.onErrorResumeNext(new HttpResponseFunc&lt;T&gt;()); &#125;&#125; 123456789101112/** * &lt;p&gt;描述：异常转换处理&lt;/p&gt; * 作者： zhouyou&lt;br&gt; * 日期： 2017/5/15 16:55 &lt;br&gt; * 版本： v1.0&lt;br&gt; */public class HttpResponseFunc&lt;T&gt; implements Function&lt;Throwable, Observable&lt;T&gt;&gt; &#123; @Override public Observable&lt;T&gt; apply(@NonNull Throwable throwable) throws Exception &#123; return Observable.error(ApiException.handleException(throwable)); &#125;&#125; map` .map(new ResultParseInterceptor()) 123456789101112public class ResultParseInterceptor&lt;T&gt; implements Func1&lt;Result&lt;T&gt;, T&gt; &#123; @Override public T call(Result&lt;T&gt; httpResult) &#123; if (httpResult == null) &#123; // seachal annotation 正常情况下，httpResult 可能是空数据 new Result（），但不应该是null,所以这种操作是合理的。 throw new ServerException(404, "获取结构为空"); &#125; else if (httpResult.state != 200) &#123; throw new ServerException(httpResult.state, httpResult.error); &#125; return httpResult.infos; &#125;&#125; flatmap map 和 flatmap 和 compose 12345github XSnowApiPostRequest.java return apiService.postForm(suffixUrl, forms) .map(new ApiResultFunc&lt;T&gt;(type)) .compose(this.&lt;T&gt;apiTransformer()); 123456map@SchedulerSupport(SchedulerSupport.NONE) public final &lt;R&gt; Observable&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) &#123; ObjectHelper.requireNonNull(mapper, "mapper is null"); return RxJavaPlugins.onAssembly(new ObservableMap&lt;T, R&gt;(this, mapper)); &#125; 1234@SchedulerSupport(SchedulerSupport.NONE) public final &lt;R&gt; Observable&lt;R&gt; compose(ObservableTransformer&lt;T, R&gt; composer) &#123; return wrap(composer.apply(this)); &#125; 12345flatMap@SchedulerSupport(SchedulerSupport.NONE) public final &lt;R&gt; Observable&lt;R&gt; flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper) &#123; return flatMap(mapper, false); &#125; ==其实从上面的代码是看不出使用区别的== 代码参考的github RxJavaDemo 12345678910private Observable&lt;String&gt; flatMapObserver() &#123; return Observable.just(1, 2, 3) .flatMap(new Func1&lt;Integer, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(Integer integer) &#123; return Observable.just("flat map:" + integer); &#125; &#125;);&#125; 123456789private Observable&lt;Integer&gt; mapObserver() &#123; return Observable.just(1, 2, 3) .map(new Func1&lt;Integer, Integer&gt;() &#123; @Override public Integer call(Integer integer) &#123; return integer * 10; &#125; &#125;); &#125; 区别在于 call()方法的return类型（返回类型)不同。 再看 123456789101112private Observable&lt;String&gt; composeObserver() &#123; Transformer&lt;Integer, String&gt; myTransformer = new Transformer&lt;Integer, String&gt;() &#123; @Override public Observable&lt;String&gt; call( Observable&lt;Integer&gt; integerObservable) &#123; return integerObservable .map(integer -&gt; "myTransforer:" + integer) .doOnNext(s -&gt; log("doOnNext:" + s)); &#125; &#125;; return Observable.just(1, 2, 3).compose(myTransformer); 返回类型是 Observable，所以compose和flatMap有一定的可比性，和map没有可比性,所以网上才会有这样一篇博文：不要打断链式结构：使用 RxJava的 compose() 操作符讲解了compose 和 flatMap的区别 下面是转载的原文部分内容： flatMap()操作符怎么样？现在你可能会好奇，compose()操作符和flatMap()操作符有何区别。他们最终都会发送出Observable，这就意味着，两者都能够用于操作符的重用？ 不同点在于compose()操作符拥有更高层次的抽象概念：它操作于整个数据流中，不仅仅是某一个被发送的事件。具体如下： compose()是唯一一个能够从数据流中得到原始Observable的操作符，所以，那些需要对整个数据流产生作用的操作（比如，subscribeOn()和observeOn()）需要使用compose()来实现。相较而言，如果在flatMap()中使用subscribeOn()或者observeOn()，那么它仅仅对在flatMap()中创建的Observable起作用，而不会对剩下的流产生影响（译者注：==深坑==，会在后面的系列着重讲解，欢迎关注）。 当创建Observable流的时候，compose()会立即执行，犹如已经提前写好了一个操作符一样，而flatMap()则是在onNext()被调用后执行，onNext()的每一次调用都会触发flatMap()，也就是说，flatMap()转换每一个事件，而compose()转换的是整个数据流。 因为每一次调用onNext()后，都不得不新建一个Observable，所以flatMap()的效率较低。事实上，compose()操作符只在主干数据流上执行操作。 如果想重用一些操作符，还是使用compose()吧，虽然flatMap()的用处很多，但作为重用代码这一点来讲，并不适用。 do doOnNext是先于onNext执行的]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F12%2FAndroid%2FRxJava%20-2019-02-11%2F</url>
    <content type="text"><![CDATA[# rxjavaSample 分析1 2 3 45678910. RxJavaDemo 分析源码： https://github.com/GAndroidProject/RxJavaDemo/blob/master/app/src/main/java/cn/com/chaoba/rxjavademo/errorhandling/RetryActivity.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 private Observable&lt;Integer&gt; retryWhenObserver() &#123; // 遇到错误就执行retryWhen，所以最后重试的次数由 zip 中的just中的个数确定。 return createObserver(). retryWhen( new Func1&lt;Observable&lt;? extends Throwable&gt;, Observable&lt;?&gt;&gt;() &#123; @Override public Observable&lt;?&gt; call(Observable&lt;? extends Throwable&gt; observable) &#123; return observable.zipWith(Observable.just(2, 3, 4, 5), new Func2&lt;Throwable, Integer, String&gt;() &#123; @Override public String call(Throwable throwable, Integer integer) &#123; // 速度太快看不出来一次一次执行 // log(throwable.getMessage() + integer); // 把"#Exception#" 字符串和 just（）依次发射出的值拼接 return throwable.getMessage() + integer; &#125; &#125;) .flatMap(new Func1&lt;String, Observable&lt;String&gt;&gt;() &#123; @Override public Observable&lt;String&gt; call(String s) &#123; return createObserver1() .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .doOnCompleted(new Action0() &#123; @Override public void call() &#123; Log.i("ErrorInterceptor:", "doOnCompleted"); &#125; &#125;)// 会被执行 .doOnError(new Action1&lt;Throwable&gt;() &#123; @Override public void call(Throwable throwable) &#123; Log.i("ErrorInterceptor:", "doOnError"); &#125; &#125;) .doOnNext(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i("ErrorInterceptor:", "doOnNext"); &#125; &#125;); &#125; &#125;) .flatMap(new Func1&lt;String, Observable&lt;Long&gt;&gt;() &#123; @Override public Observable&lt;Long&gt; call(String s) &#123; // 把zip中拼接的异常输出。 log(s); // 返回一个Observable，计时执行， return Observable.timer(1, TimeUnit.SECONDS); // return Observable.just( 1L); &#125; &#125;); &#125; &#125;);// .onErrorResumeNext(); &#125; private Observable&lt;Integer&gt; createObserver() &#123; return Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123; @Override public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123; log("subscribe"); for (int i = 0; i &lt; 3; i++) &#123; if (i == 2) &#123; subscriber.onError(new Exception("#Exception#")); &#125; else &#123; subscriber.onNext(i); &#125; &#125; &#125; &#125;); &#125; private Observable&lt;String&gt; createObserver1() &#123; return Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; log("subscribe"); for (int i = 0; i &lt; 3; i++) &#123; if (i == 2) &#123; subscriber.onError(new Exception("#Exception#")); &#125; else &#123; subscriber.onNext(i + ""); &#125; &#125; &#125; &#125;); &#125;&#125; createObserver1()会发出错误，注意后面有个1， createObserver1在retryWhen的 flatMap里面，createObserver1出现错误是会执行 flatMap 的doOnError的，发现日志：102-11 14:42:21.988 27196-27196/cn.com.chaoba.rxjavademo I/ErrorInterceptor:: doOnError 发现执行结构，==日志和屏幕说明了==，retryWhen也是按照普通正常的onNext()-onCompleted()、onNext()-onError(),顺序执行， 如果没有报错执行， 依次执行onNext()(可能多个)、onCompleted(), 如果报错了，依次执行onNext()(可能多个,可能0个)、onError()。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F11%2FAndroid%2FTextInputLayout-2019-01-15%2F</url>
    <content type="text"><![CDATA[TextInputLayout!--参考 https://blog.csdn.net/android_freshman/article/details/51136657。 https://juejin.im/post/587c1637128fe10057f745db -- 搜索关键字：TextInputLayout 自定义因为TextInputLayout有一条默认的theme，所以如果想改变就要自定义]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F11%2FJava%2Fimages%2FJava2019-02-01%2F</url>
    <content type="text"><![CDATA[# 转码1Double.parseDouble() ; Double.valueOf(); 看源码后就会发现，Double.valueOf其实底层还是用的 Double.parseDouble() ;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F10%2FVisual%20Studio%20Code%E8%AE%BE%E7%BD%AE%E4%B8%AD%E6%96%87-2019-02-10%2F</url>
    <content type="text"><![CDATA[Visual Studio Code设置中文一、VS Code 升级新版版后，默认仅仅支持英文想在vs code中使用中文语言，可以在线下载语言包进行配置。 补充说明：目前版本，搜索下载插件，重新启动的话，点击右下角的OK，可以自动添加配置内容配置步骤： 下载语言包 插件 输入“Chinese” ，安装插件 “Chinese (Simplified) Language Pack for Visual Studio Code” Ctrl +Shift +P快捷键 输入 “Configure Language” 配置本地语言 将local的值，设置为中文简体“zh-CN” ,当你删除之前的语言设置，在“locale”后面输入冒号或引号时会提示可用的选项。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F02%2F10%2FVersionControl%2FGit%20%E5%A4%B4%E5%83%8F%E4%BF%AE%E6%94%B9-2019-02-10%2F</url>
    <content type="text"><![CDATA[Git 头像修改平时使用git gui工具，如 tower、sourtree 时发现 git 账号的头像不是自己 github 的头像（当然提供 git 托管服务的网站有多个，如 gitlab，）或者是空白，所以就搜索一下找到了解决方法。 第一种是直接在你当前托管的git服务网站中自定义上传头像 第二种通过第三方网站修改，基本上所有git服务网站都遵循这点，下面说的就是该模式 其实很简单！！！ 1https://zh-tw.gravatar.com/ 复制上门的网址 gravatar.com 网站注册一个账号！ 使用 git 服务 同名 的邮箱！！！重点，必须和 git 用户邮箱一致！ 在网站中上传头像，保存成功，稍等片刻！刷新你的git服务网站！！神奇的事情就发生了！！ 如果有新的git账号头像需求！直接在已有的 gravatar.com 账户中，添加新邮箱地址即可！]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F01%2F30%2Fgithub%20cheat%20sheet-2019-01-17%2F</url>
    <content type="text"><![CDATA[GitHub’s search supports a variety of different operations. Here’s a quick cheat sheet for some of the common searches.For more information, visit our search help section. Basic search This search Finds repositories with… cat stars:&gt;100 Find cat repositories with greater than 100 stars. user:defunkt Get all repositories from the user defunkt. tom location:”San Francisco, CA” Find all tom users in “San Francisco, CA”. join extension:coffee Find all instances of join in code with coffee extension. NOT cat Excludes all results containing cat. Repository search Repository search looks through the projects you have access to on GitHub. You can also filter the results: This search Finds repositories with… cat stars:&gt;100 Find cat repositories with greater than 100 stars. user:defunkt Get all repositories from the user defunkt. pugs pushed:&gt;2013-01-28 Pugs repositories pushed to since Jan 28, 2013. node.js forks: Code search looks through the files hosted on GitHub. You can also filter the results: This search Finds repositories with… install repo:charles/privaterepo Find all instances of install in code from the repository charles/privaterepo. shogun user:heroku Find references to shogun from all public heroku repositories. join extension:coffee Find all instances of join in code with coffee extension. system size:&gt;1000 Find all instances of system in code of file size greater than 1000kbs. examples path:/docs/ Find all examples in the path /docs/. replace fork:true Search replace in the source code of forks. Issue search Issue search looks through issues and pull requests on GitHub. You can also filter the results: This search Finds issues… encoding user:heroku Encoding issues across the Heroku organization. cat is:open Find cat issues that are open. strange comments:&gt;42 Issues with more than 42 comments. hard label:bug Hard issues labeled as a bug. author:mojombo All issues authored by mojombo. mentions:tpope All issues mentioning tpope. assignee:rtomayko All issues assigned to rtomayko. exception created:&gt;2012-12-31 Created since the beginning of 2013. exception updated: User search finds users with an account on GitHub. You can also filter the results: This search Finds repositories with… fullname:”Linus Torvalds” Find users with the full name “Linus Torvalds”. tom location:”San Francisco, CA” Find all tom users in “San Francisco, CA”. chris followers:100..200 Find all chris users with followers between 100 and 200. ryan repos:&gt;10 Find all ryan users with more than 10 repositories.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F01%2F30%2FJson%E8%A7%A3%E6%9E%902019-01-21%2F</url>
    <content type="text"><![CDATA[Json 解析JSONObject Integer解析报错问题如果用Objcet接收data未解析时的类型是 Integer。 12345678910111213private Map&lt;String, Object&gt; data; // 获取Map中数据,改为反射方式 public &lt;T&gt; T getDataByKey(String key, Class&lt;T&gt; clazz) &#123; if (data != null) &#123; //报错位置 JSONObject jsonObject = (JSONObject) data.get(key); return JSONObject.toJavaObject(jsonObject, clazz); &#125; else &#123; // return (T) new Object(); return null; &#125; &#125; 报错:1Integer cannot be cast to com.alibaba.fastjson.JSONObject 如果用JSONObject接收12345678910111213private Map&lt;String, JSONObject&gt; data; // 获取Map中数据,改为反射方式 public &lt;T&gt; T getDataByKey(String key, Class&lt;T&gt; clazz) &#123; if (data != null) &#123; JSONObject jsonObject = data.get(key); return JSONObject.toJavaObject(jsonObject, clazz); &#125; else &#123; // return (T) new Object(); return null; &#125; &#125; 报错: 1E/onError: onError:syntax error, expect &#123;, actual int, pos 69, line 1, column 70&#123;"code":200,"ok":true,"msg":"未找到该许可证号","data":&#123;"needLicensePicture":1&#125;&#125; 1E/onError: onError:com.alibaba.fastjson.JSONObject cannot be cast to com.ctitc.deep.bean.base.BaseUser 最后的解决方案12345678910111213141516// 获取Map中数据,改为反射方式 public &lt;T&gt; T getDataByKey(String key, Class&lt;T&gt; clazz) &#123; if (data != null) &#123; Object object = data.get(key); //数组和对象，都会被fastjson自动转换为JSON对象 if (object instanceof JSON) &#123; return JSONObject.toJavaObject((JSON) object, clazz); &#125; else &#123; //普通类型，如Integer等，直接转 return (T) object; &#125; &#125; else &#123; // return (T) new Object(); return null; &#125; &#125;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F01%2F30%2FAndroid%2F%E5%8C%BA%E5%9F%9F%E3%80%81%E7%9C%81%E5%B8%82%E5%8E%BF%E3%80%81%E5%9C%B0%E5%8C%BA%E9%80%89%E6%8B%A9-2019-01-26%2F</url>
    <content type="text"><![CDATA[区域、省市县、地区选择-2019-01-26关键字： PickerView select choice choose electoption]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F01%2F30%2FAndroid%2Fadb%E5%91%BD%E4%BB%A42019-01-03%2F</url>
    <content type="text"><![CDATA[adb 命令安装1adb install xxx.apk 卸载123adb devices adb shell pm list packagesadb uninstall com.xxx.xxx 打开命令行，输入adb devices，查看设备是否连接； 输入adb shell pm list packages，查看设备已有的程序列表，找到需要卸载的程序包名; 如果有多个设备 1adb -s 设备id shell pm list packages 输入adb uninstall com.xxx.xxx（需要卸载的程序包名）； 如果有多个设备 1adb -s 192.168.56.101:5555（设备id） uninstall com.tencent.qqpimsecure 4.adb 启动应用]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F01%2F30%2FAndroid%2FRxJava1%E5%92%8CRxJava2%E7%9A%84%E5%8F%98%E5%8C%96-2019-01-25%2F</url>
    <content type="text"><![CDATA[RxJava1和RxJava2的变化-2019-01-252.x 将 1.x 中的 Func1 和 Func2 改为了 Function 和 BiFunction。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F01%2F30%2FAndroid%2FRxJava%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8CRetrofit%E5%AE%9E%E7%8E%B0token%E8%BF%87%E6%9C%9F%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0(%E6%9B%B4%E6%96%B0)2019-01-25%2F</url>
    <content type="text"><![CDATA[# rangerange操作符根据出入的初始值n和数目m发射一系列大于等于n的m个值.range(n,m)n,n+1，n+m-1举个例子：rang(2,2),发射的是 2，3]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F01%2F30%2FAndroid%2FRetrofit%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86-2019-01-25%2F</url>
    <content type="text"><![CDATA[Retrofit统一异常错误处理-2019-01-25.md错误处理 如果服务器返回Code 未来终端未来终端中12345public class Result &#123; private boolean ok;// private String msg; private Map&lt;String, Object&gt; data; ok只能判断业务是否成功， 当然网络不成功 ok肯定不是true,例如401。但是 ok是false的时候，网络不一定不成功，例如密码错误。 200是网络请求ok，但是业务可能不成功，服务器此时会有一些提示信息，比如“密码不正确”、“没有权限”等等。这些会在 RxJava的onNext中处理，要不要把rsult!=null&amp;&amp;result.ok==false的情况的拦截到 onError中处理？。 RxEasyHttp 分析搜索onErrorResumeNext 得到 123456HandleErrTransformer. Java 36RxUtil. Java 88 RxUtil. Java 113 BaseStrategy. Java 53 BaseStrategy. Java 91 BaseStrategy. Java 124PollActivity. Java 61 搜索retryWhen得到 1234567891011PutRequest. Java 68 PutRequest. Java 103 DeleteRequest. Java 74GetRequest. Java 68GetRequest. Java 101 PostRequest. Java 68 PostRequest. Java 101CustomRequest. Java 81CustomRequest. Java 104CustomRequest. Java 132 DownloadRequest. Java 78]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F01%2F15%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Vagrant%E7%9A%84%E8%99%9A%E6%8B%9F%E7%9B%92vboxheadless%E8%BF%9B%E7%A8%8B%E4%BD%BF%E7%94%A8100%EF%BC%85%E7%9A%84cpu-2019-01-02%2F</url>
    <content type="text"><![CDATA[为什么使用Vagrant的虚拟盒vboxheadless进程使用100％的cpu？https://stackoverflow.com/questions/28293238/why-does-virtual-box-vboxheadless-process-using-vagrant-use-100-of-my-cpu https://www.vagrantup.com/downloads.html 1.下载 vagrant，安装， 2.在命令行中执行，vagrant plugin install vagrant-vbguest 有效的方法系统-&gt;处理器-&gt;勾选“启用PAE / NX”框我发现只需勾选“启用PAE / NX”框就会将空闲CPU使用率降低到可接受的9％。关键字： virtualbox genymotion mac cpu VBoxHeadlesshttps://tickett.wordpress.com/2014/11/19/virtualbox-high-cpu-usage-on-osx/]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F01%2F15%2FVersionControl%2F%E5%9C%A8bitbucket%20%E5%88%A0%E9%99%A4%E5%88%86%E6%94%AF-2019-01-09%2F</url>
    <content type="text"><![CDATA[在bitbucket删除分支删除分支第一步 如果遇到主分支不能删除，则改变主分支， How to change the main branch in bitbucket 参考： https://stackoverflow.com/questions/37550492/how-to-change-the-main-branch-in-bitbucket]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F01%2F15%2FAndroid%2F%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E4%B8%AD%E4%BA%8B%E4%BB%B6%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95requestDisallowInterceptTouchEvent-2019-01-03%2F</url>
    <content type="text"><![CDATA[事件分发中事件冲突解决方法requestDisallowInterceptTouchEvent的理解，问题和解决方法ViewPager来实现左右滑动切换tab，如果tab的某一项中嵌入了水平可滑动的View就会出现滑动冲突，比如想滑动tab页中的可水平滑动的View，却导致tab切换。 解决方法是requestDisallowInterceptTouchEvent(true)调用该方法，一旦底层View收到touch的action后调用这个方法那么父层View就不会再调用onInterceptTouchEvent了，也无法截获以后的action。代码一般如下： deep-CombinedChartInViewPager12345678910111213141516171819@Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; boolean bol = super.onInterceptTouchEvent(ev); final int action = ev.getAction(); // &amp; switch (action &amp; MotionEvent.ACTION_MASK) &#123; case MotionEvent.ACTION_DOWN: &#123; final ViewParent parent = getParent(); if (parent != null) &#123; //诉父View，也就是LinearLayout不要拦截该控件上的触摸事件 parent.requestDisallowInterceptTouchEvent(true); &#125; break; &#125; default: break; &#125; return bol; &#125; 当用户按下的时候，我们告诉父组件，不要拦截我的事件（这个时候子组件是可以正常响应事件的）， 一些疑惑的追踪父View默认拦截？可左右滑动的View的父View是LinearLayout,LinearLayout没有对父View的事件方法做重写， 再看LinearLayout父类ViewGroup的onInterceptHoverEvent源码： 123456789101112public boolean onInterceptHoverEvent(MotionEvent event) &#123; if (event.isFromSource(InputDevice.SOURCE_MOUSE)) &#123; final int action = event.getAction(); final float x = event.getX(); final float y = event.getY(); if ((action == MotionEvent.ACTION_HOVER_MOVE || action == MotionEvent.ACTION_HOVER_ENTER) &amp;&amp; isOnScrollbar(x, y)) &#123; return true; &#125; &#125; return false; &#125; onInterceptHoverEvent 默认返回false（及默认不拦截，分发到子类，） 那么到底是哪个地方默认拦截了呢？我们再看ViewPager源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141@Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; /* * This method JUST determines whether we want to intercept the motion. * If we return true, onMotionEvent will be called and we do the actual * scrolling there. */ final int action = ev.getAction() &amp; MotionEvent.ACTION_MASK; // Always take care of the touch gesture being complete. if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) &#123; // Release the drag. if (DEBUG) Log.v(TAG, "Intercept done!"); resetTouch(); return false; &#125; // Nothing more to do here if we have decided whether or not we // are dragging. if (action != MotionEvent.ACTION_DOWN) &#123; if (mIsBeingDragged) &#123; if (DEBUG) Log.v(TAG, "Intercept returning true!"); return true; &#125; if (mIsUnableToDrag) &#123; if (DEBUG) Log.v(TAG, "Intercept returning false!"); return false; &#125; &#125; switch (action) &#123; case MotionEvent.ACTION_MOVE: &#123; /* * mIsBeingDragged == false, otherwise the shortcut would have caught it. Check * whether the user has moved far enough from his original down touch. */ /* * Locally do absolute value. mLastMotionY is set to the y value * of the down event. */ final int activePointerId = mActivePointerId; if (activePointerId == INVALID_POINTER) &#123; // If we don't have a valid id, the touch down wasn't on content. break; &#125; final int pointerIndex = ev.findPointerIndex(activePointerId); final float x = ev.getX(pointerIndex); final float dx = x - mLastMotionX; final float xDiff = Math.abs(dx); final float y = ev.getY(pointerIndex); final float yDiff = Math.abs(y - mInitialMotionY); if (DEBUG) Log.v(TAG, "Moved x to " + x + "," + y + " diff=" + xDiff + "," + yDiff); if (dx != 0 &amp;&amp; !isGutterDrag(mLastMotionX, dx) &amp;&amp; canScroll(this, false, (int) dx, (int) x, (int) y)) &#123; // Nested view has scrollable area under this point. Let it be handled there. mLastMotionX = x; mLastMotionY = y; mIsUnableToDrag = true; return false; &#125; if (xDiff &gt; mTouchSlop &amp;&amp; xDiff * 0.5f &gt; yDiff) &#123; if (DEBUG) Log.v(TAG, "Starting drag!"); mIsBeingDragged = true; requestParentDisallowInterceptTouchEvent(true); setScrollState(SCROLL_STATE_DRAGGING); mLastMotionX = dx &gt; 0 ? mInitialMotionX + mTouchSlop : mInitialMotionX - mTouchSlop; mLastMotionY = y; setScrollingCacheEnabled(true); &#125; else if (yDiff &gt; mTouchSlop) &#123; // The finger has moved enough in the vertical // direction to be counted as a drag... abort // any attempt to drag horizontally, to work correctly // with children that have scrolling containers. if (DEBUG) Log.v(TAG, "Starting unable to drag!"); mIsUnableToDrag = true; &#125; if (mIsBeingDragged) &#123; // Scroll to follow the motion event if (performDrag(x)) &#123; ViewCompat.postInvalidateOnAnimation(this); &#125; &#125; break; &#125; case MotionEvent.ACTION_DOWN: &#123; /* * Remember location of down touch. * ACTION_DOWN always refers to pointer index 0. */ mLastMotionX = mInitialMotionX = ev.getX(); mLastMotionY = mInitialMotionY = ev.getY(); mActivePointerId = ev.getPointerId(0); mIsUnableToDrag = false; mIsScrollStarted = true; mScroller.computeScrollOffset(); if (mScrollState == SCROLL_STATE_SETTLING &amp;&amp; Math.abs(mScroller.getFinalX() - mScroller.getCurrX()) &gt; mCloseEnough) &#123; // Let the user 'catch' the pager as it animates. mScroller.abortAnimation(); mPopulatePending = false; populate(); mIsBeingDragged = true; requestParentDisallowInterceptTouchEvent(true); setScrollState(SCROLL_STATE_DRAGGING); &#125; else &#123; completeScroll(false); mIsBeingDragged = false; &#125; if (DEBUG) &#123; Log.v(TAG, "Down at " + mLastMotionX + "," + mLastMotionY + " mIsBeingDragged=" + mIsBeingDragged + "mIsUnableToDrag=" + mIsUnableToDrag); &#125; break; &#125; case MotionEvent.ACTION_POINTER_UP: onSecondaryPointerUp(ev); break; &#125; if (mVelocityTracker == null) &#123; mVelocityTracker = VelocityTracker.obtain(); &#125; mVelocityTracker.addMovement(ev); /* * The only time we want to intercept motion events is if we are in the * drag mode. * 我们唯一想要拦截手势事件的时候是在拖动模式下 */ return mIsBeingDragged; &#125; 重点是在最后一句，也就是在拖动模式下， ViewPager拦截手势事件，交于自己的onTouchEvent方法去处理。 找到了拦截的位置，那么接下来的事情就是，告诉让子View告诉父View,不要拦截，也就是本文的主角requestDisallowInterceptTouchEvent（） 我们看viewgroup的requestDisallowInterceptTouchEvent方法干了什么？ 这个函数有个bool参数，我们先看为true的情况，非常简单，2件事情，一件是把mGroupFlags里面的某一位置成true，然后再调用parent的requestDisallowInterceptTouchEvent（true）方法。总的来说就是把本viewgroup以及祖先viewgroup的那一个标志位都置为true。 123456789101112131415161718public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) &#123; if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) &#123; // We're already in this state, assume our ancestors are too return; &#125; if (disallowIntercept) &#123; mGroupFlags |= FLAG_DISALLOW_INTERCEPT; &#125; else &#123; mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT; &#125; // Pass it up to our parent if (mParent != null) &#123; mParent.requestDisallowInterceptTouchEvent(disallowIntercept); &#125;&#125; 看最后一行代码，requestDisallowInterceptTouchEvent 会一直向上一个父ViewGroup接力。最终就会告诉ViewPager不要拦截子View时间。 参考:https://www.jianshu.com/p/7e92121814edhttps://blog.csdn.net/litefish/article/details/51779482 关于网上说 requestDisallowInterceptTouchEvent失效的问题，遇到再详细讨论关于requestDisallowInterceptTouchEvent的源码有时间再详细分析]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F01%2F15%2FAndroid%2FAndroidStudio%E5%88%A0%E9%99%A4%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB(Class)%E5%92%8C%E8%B5%84%E6%BA%90(Resource)%202019-01-04%2F</url>
    <content type="text"><![CDATA[AndroidStudio删除未使用的类(Class)和资源(Resource) -2019-01-04删除类要在整个项目上运行，请转到Analyze -&gt; Run inspection by name…，键入Unused declaration并选择所需的范围。然后仔细检查输出并在需要时将某些类标记为入口点。现在，您可以Unused declaration在列表中选择节点，并立即Safe delete对所有未使用的声明执行操作。 同时可以选择是检查 Class还是检查Method这样就可以只删除不用的类，而不删除不用的Method。 还可以按编程语言匹配要删除的内容，厉害 删除kotlin对于Kotlin，输入Unused symbol有类似的检查Kotlin | Redundant constructs | Unused symbol。 删除资源res文件对于res，输入Unused resources然后选择 remove，注意，按钮可能被隐藏需要展开按钮组，]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2019%2F01%2F15%2FAndroid%2FMac%20%E4%B8%8B%20Android%20%E5%8F%8D%E7%BC%96%E8%AF%91-2018-12-30%2F</url>
    <content type="text"><![CDATA[Mac 下 Android 反编译-2018-12-301.环境准备1.1安装Apktool Mac OS X： 下载Mac 包装器脚本（右键单击，将链接另存为apktool，注意：格式选择所有文件） 下载apktool-2（在这里找到最新的） 将下载的jar重命名为 apktool.jar 将两个文件（apktool.jar＆apktool）移动到/usr/local/bin（需要root） 确保两个文件都是可执行的（chmod +x）,注意点：在操作过程中可能会报错权限相关的问题,需要在 terminal 中用命令对2个文件进行取消权限操作。 12chmod +x /usr/local/bin/apktool.jar //chmod +x 取消权限chmod +x /usr/local/bin/apktool 尝试apktool通过cli 运行整个命令过程就是下面这样的： 参考：https://ibotpeaches.github.io/Apktool/install/https://www.jianshu.com/p/a21edfa632cfhttp://www.devio.org/2018/05/08/Android-reverse-engineering-for-mac/ 1.2 dex2jar下载1. https://sourceforge.net/projects/dex2jar/files/（可能需要科学上网） 下载2. https://github.com/pxb1988/dex2jar 解压就可以使用，具体放在哪个文件夹按个人喜好 1.3 JD-GUIJD-GUI下载：http://jd.benow.ca/此处可能会遇到再 jdk&gt;8的情况下 jd-gui 打不开的情况(jd-gui 闪退)，解决方法： >=JDK9 add new feature “module”, access restricted class of some module. modify Info.plist VMOptions=-Xms512m –add-opens java.base/jdk.internal.loader=ALL-UNNAMED –add-opens jdk.zipfs/jdk.nio.zipfs=ALL-UNNAMED or modify universalJavaApplicationStub.sh or workaround 12345macOSjava --add-opens java.base/jdk.internal.loader=ALL-UNNAMED --add-opens jdk.zipfs/jdk.nio.zipfs=ALL-UNNAMED -jar /Applications/JD.app/Contents/Resources/Java/jd-gui-1.4.0.jarwin/linuxjava --add-opens java.base/jdk.internal.loader=ALL-UNNAMED --add-opens jdk.zipfs/jdk.nio.zipfs=ALL-UNNAMED -jar jd-gui-1.4.0.jar 参考：https://github.com/java-decompiler/jd-gui/issues/187#issuecomment-333020310 2. 开始反编译2.1 反编译APK（工具apktool）得到 res 文件12cd /你存放apk的目录apktool d xxx.apk //该命令执行后会在同级目录下生成一个与你编译的apk同名的目录 上述命令反编译了 apk，执行结果如下： 反编译后生成的目录中你会看到相关的资源文件： 由于APkTool只能将资源文件提取处理，对于.dex类型的文件是无法查看的，这里就需要用到dex2jar了。 2.2 把.dex 文件转为 jar 文件 使用解压软件将apk进行解压，注意解压 apk 含有 dex 文件，apktool 反编译得到的没有 dex文件 直接解压apk和使用apktool反编译apk都能获得AndroidManifest.xml，但直接解压获得的AndroidManifest.xml是乱码的，无法直接查看； 直接解压apk获得res资源文件是不包含resources.arsc部分的，而使用apktool反编译出来的res是包含的； 将这个dex文件拷贝到下载解压的dex2jar目录下： 然后执行如下代码进行反编译： 12cd /你的dex2jar解压目录 也就是上面图中存放class.dex文件的目录sh d2j-dex2jar.sh classes.dex 对于解压后有多个.dex文件的 apk，可以不把class.dex拷贝到dex2jar解压目录中；把 apk 文件拷贝到dex2jar解压目录中，直接在apk上使用multidex支持运行dex2jar。所有类* .dex都转换为单个jar文件。 1sh d2j-dex2jar.sh the-apk-witch-mutidex.apk 参考：https://github.com/pxb1988/dex2jar/issues/63#issuecomment-192183968 可能会报错： 1./d2j_invoke.sh: Permission denied 解决和apktool一样： 1sudo chmod +x d2j_invoke.sh //sudo chmod +取消权限 然后再执行： 1sh d2j-dex2jar.sh classes.dex 命令过程如下： 生成的.jar 文件（如上图） 需要使用JD-GUI 进行查看，将classes-dex2jar.jar拖拽到JD-GUI界面上即可。 以分析豆瓣为例!--参考： https://github.com/android-cn/android-discuss/issues/699 https://www.jianshu.com/p/0693b841c83b https://blog.csdn.net/cxc19890214/article/details/71603299 -- 打开一个界面，找到栈顶的 Activity小组详情根据截图找到截图对应的 Activity 和 Fragment。 1.12345SeachaldeMacBook-Pro:~ seachal$ adb shell dumpsys activity topTASK com.douban.frodo id=421 ACTIVITY com.douban.frodo/.group.activity.GroupTopicActivity 7b1ac15 pid=5349 Local Activity dd2ea32 State: mResumed=true mStopped=false mFinished=false 的到GroupTopicActivity，包结构：com.douban.frodo.group.activity.GroupTopicActivity 2.找到一些 Fragment 的信息 3.1234#0: PagedCommentsFragment&#123;ca83600 #0 id=0x7f0907bd&#125; #1: ReactionsFragment&#123;8132e39 #1 id=0x7f0907bd&#125; #2: ResharesFragment&#123;1ff1ac4 #2 id=0x7f0907bd&#125; #3: CollectionsFragment&#123;b5e4dad #3 id=0x7f0907bd&#125; 每个 Fragment 都要分析， PagedCommentsFragment12localLayoutInflater.inflate(R.layout.layout_comments_fragment_pagination_label, this.mRootLayout, true); localLayoutInflater.inflate(R.layout.layout_comments_fragment_pagination_panel, this.mRootLayout, true); ReactionsFragment1return paramLayoutInflater.inflate(R.layout.fragment_content_likes, paramViewGroup, false); ResharesFragment12345@Nullablepublic View onCreateView(@NonNull LayoutInflater paramLayoutInflater, @Nullable ViewGroup paramViewGroup, @Nullable Bundle paramBundle)&#123; return paramLayoutInflater.inflate(R.layout.fragment_content_reshares, paramViewGroup, false);&#125; 查看 Fragment的Layout是否和真实的页面对应。 CollectionsFragment12345@Nullable public View onCreateView(@NonNull LayoutInflater paramLayoutInflater, @Nullable ViewGroup paramViewGroup, @Nullable Bundle paramBundle) &#123; return paramLayoutInflater.inflate(R.layout.fragment_content_collections, paramViewGroup, false); &#125; 感觉截图和下面的布局是对应的123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;FrameLayout android:layout_width="fill_parent" android:layout_height="fill_parent" xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;com.douban.frodo.baseproject.view.newrecylview.EndlessRecyclerView android:id="@id/list" android:background="@color/background" android:paddingBottom="50.0dip" android:clipToPadding="false" android:layout_width="fill_parent" android:layout_height="fill_parent" android:drawSelectorOnTop="true" android:splitMotionEvents="false" /&gt; &lt;com.douban.frodo.baseproject.view.LoadingLottieView android:id="@id/loading_lottie" android:background="@color/white" android:visibility="gone" android:layout_width="fill_parent" android:layout_height="wrap_content" android:scaleType="fitXY" app:lottie_loop="true" /&gt;&lt;/FrameLayout&gt; 首页详情 123456// StatusDetailActivity,首页的详细public class StatusDetailActivity extends NativeHeaderContentStructureActivity&lt;Status&gt; implements StatusDetailHeaderView.StatusViewCallback, StatusDetailVideoPlayer.DetailVideoFullScreenListener&#123; android studio 3 ddms参考：https://blog.csdn.net/sinat_24037895/article/details/7994499312 3 通过structure_bottom_fix_layout 找到activity_structure_layout，通过 activity_structure_layout找到public abstract class StructureActivity&lt;T&gt;,又发现GroupTopicActivity 其实继承自 StructureActivity， 如果在一个 Activity 中找不到对应的layout，那么去找 Activity中的Fragment的 Layout Activity的父类的 Layout 最后发现，从底部划上去的评论区域在 FrodoCoordinatorLayout中，FrodoCoordinatorLayout继承自CoordinatorLayout，CoordinatorLayout具有滑动特性。 命名：继承具有特性的 View，最好命名时有所体现。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F11%2F17%2FVersionControl%2F2018-04-15%2F</url>
    <content type="text"><![CDATA[#在add文件的时候，不小心把add to working copy点击成了下面的ignore。 以至于，自己new的文件，在finder里面能够看到文件，但在cornerstone里就看不到，无法add commit。怎样恢复呢？ 打开右上角图标顺序使左上角两个图标选中， 然后看到点击蓝色图标点击 Revert to last Update 最后保存 最后ignore文件就显示了。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F11%2F17%2FMac%2F%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E9%9B%86%E8%BD%AC%E6%8D%A2%E4%B8%BAUTF-i%E8%84%9A%E6%9C%AC%EF%BC%88file%20batch%20convert%20char%20set%20%EF%BC%892018-08-19%2F</url>
    <content type="text"><![CDATA[#最近遇到一个大项目，项目使用的encoding 有GBK也有UTF-8， 在intellij中虽然可以一个一个conver，但是感觉太慢了，并且reload为UTF-8也不是长久之计，在Git中仍然是乱码。 查阅了一些资料，写个脚本终于批量把gbk 转换为 utf-8了。这是在mac 10.13中测试的示例。按名称查找文件，转换编码，然后替换原始文件。完美。 新建一个名为 ConvertEncoding.sh文件 将下面的完整代码复制到shell脚本中。 123456789101112#!/bin/bash find ./ -name *.java -type f | \ (while read file; do if [[ "$file" != *.DS_Store* ]]; then if [[ "$file" != *-utf8* ]]; then iconv -f GBK -t UTF-8 "$file" &gt; "$file-utf8"; rm $file; echo mv "$file-utf8" "$file"; mv "$file-utf8" "$file"; fi fi done); ./ 要替换为自己的项目文件夹。 把shell文件拖到terminal中 enter执行。 12345678bogon:~ username$ /Users//Documents/batchconvert.sh -bash: /Users/username/Documents/batchconvert.sh: Permission deniedbogon:~ username$ chmod 777 batchconvert.shchmod: batchconvert.sh: No such file or directorybogon:~ username$ chmod 777 /Users/username/Documents/batchconvert.sh bogon:~ username$ bogon:~ username$ bogon:~ username$ /Users/username/Documents/batchconvert.sh 其中 chmod 777 /Users/username/Documents/batchconvert.sh是给batchconvert.sh赋予全新啊。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F11%2F17%2FReactNative%2F2018-02-23%2F</url>
    <content type="text"><![CDATA[WebStorm 运行ReactNative配置未发布 1.在最上面找到Run菜单选择当中的Edit 2. 3. 4.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F11%2F17%2FJava%2F2018-06-21%2F</url>
    <content type="text"><![CDATA[# // @Override// @DataSource(“busi”)// @Transactional(readOnly = true, propagation = Propagation.REQUIRED, rollbackFor = Exception.class)// public OperateResult intelligentIdentification(MultipartFile file) {//// UploadActionBean result = new UploadActionBean();// List cigaretteInfoList = new ArrayList&lt;&gt;() ;////// 模式的识别结果数据// JSONArray jsonArray = new JSONArray();// JSONObject jsonObject = new JSONObject();// jsonObject.put(“barCode”, “6901028001687”);// jsonObject.put(“ratio”, “99.5”);// jsonArray.add(jsonObject);// jsonObject = new JSONObject();// jsonObject.put(“barCode”, “6901028081474”);// jsonObject.put(“ratio”, “49.5”);// jsonArray.add(jsonObject);// // 图片识别结果返回一个list的请求结果//// 如果请求成功， 并且，返回的list不为null，size大于0// if (true) {// cigaretteInfoList = cigaretteInfoMapper.getCigaretteList(jsonArray);//// 从数据库中查出的数据对象，// for (int i = 0; cigaretteInfoList != null &amp;&amp; i &lt; cigaretteInfoList.size(); i++) {//// for (int j = 0; j &lt; jsonArray.size(); j++) {// if (cigaretteInfoList.get(i).getBarBoxBarCode().equals(jsonArray.getJSONObject(j).getString(“barCode”))){//// cigaretteInfoList.get(i).setRatio(jsonArray.getJSONObject(j).getString(“ratio”));// }// }// }// }// return OperateResultCode.SUCCESS.getResult().setDataList(cigaretteInfoList);// } @Override @DataSource(&quot;busi&quot;) @Transactional(readOnly = true, propagation = Propagation.REQUIRED, rollbackFor = Exception.class) public OperateResult intelligentIdentification(MultipartFile file) { // UploadActionBean result = new UploadActionBean(); List cigaretteInfoList = new ArrayList&lt;&gt;() ; // 模式的识别结果数据 JSONArray jsonArray = new JSONArray(); JSONObject jsonObject = new JSONObject(); jsonObject.put(“barCode”, “6901028001687”); jsonObject.put(“ratio”, “99.5”); jsonArray.add(jsonObject); jsonObject = new JSONObject(); jsonObject.put(“barCode”, “6901028081474”); jsonObject.put(“ratio”, “49.5”); jsonArray.add(jsonObject); // 图片识别结果返回一个list的请求结果// 如果请求成功， 并且，返回的list不为null，size大于0 if (true) {// 从数据库中查出的数据对象， cigaretteInfoList = cigaretteInfoMapper.getCigaretteList(jsonArray); Map&lt;String, CigaretteInfo&gt; mapCigarette = new HashMap&lt;String, CigaretteInfo&gt;(); for (CigaretteInfo cigaretteInfo : cigaretteInfoList) { mapCigarette.put(cigaretteInfo.getBarBoxBarCode(), cigaretteInfo); } for (int j = 0; j &lt; jsonArray.size(); j++) { if (mapCigarette.get(jsonArray.getJSONObject(j).getString(&quot;barCode&quot;)).getBarBoxBarCode().equals(jsonArray.getJSONObject(j).getString(&quot;barCode&quot;))){ mapCigarette.get(jsonArray.getJSONObject(j).getString(&quot;barCode&quot;)).setRatio(jsonArray.getJSONObject(j).getString(&quot;ratio&quot;)); } } } return OperateResultCode.SUCCESS.getResult().setDataList(cigaretteInfoList); }]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F11%2F17%2FBlogBuild%2FMarkDown%E6%B3%A8%E9%87%8A%EF%BC%8C%E9%9A%90%E8%97%8F%E6%96%87%E5%AD%97_2018-02-09%2F</url>
    <content type="text"><![CDATA[#MarkDown注释，隐藏文字1 &lt;!--.bg-blue--&gt; 弗朗茨·李斯特（Franz Liszt，1811年10月22日－1886年7月31日），著名匈牙利作曲家、钢琴家、指挥家，是浪漫主义前期最杰出的代表人物之一。 2 弗朗茨·李斯特（Franz Liszt，1811年10月22日－1886年7月31日），著名匈牙利作曲家、钢琴家、指挥家，是浪漫主义前期最杰出的代表人物之一。 3 弗朗茨·李斯特（Franz Liszt，1811年10月22日－1886年7月31日），著名匈牙利作曲家、钢琴家、指挥家，是浪漫主义前期最杰出的代表人物之一。 《钟》（意大利语：La campanella），或译作《康派涅拉》，是弗朗茨·李斯特创作的《帕格尼尼大练习曲》6首中第3首的钢琴独奏曲。 或者你可以走得更远： 为了提高平台兼容性（并保存一个按键），也可以使用#（这是一个合法的超链接目标），而不是&lt;&gt;： 参考：https://stackoverflow.com/questions/4823468/comments-in-markdown 参考：https://github.com/fan2/Markdown/blob/master/Markdown%20Syntax.md]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F11%2F17%2FBlogBuild%2F%E5%B8%B8%E7%94%A8%E5%8D%9A%E5%AE%A2Metaweblog%20Api%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[常用博客Metaweblog Api地址 CSDN： http://write.blog.csdn.net/xmlrpc/index 博客园（cnblogs)：http://www.cnblogs.com/Blog名(你的用户名)/services/metaweblog.aspx。其中 Blog 名 请换为您的博客名。cnblogs 的博客后台设置，拉到最下面，也可以找到这个网址。比如说我的是 http://rpc.cnblogs.com/metaweblog/Seachal 两者网址不同，但是效果一样。 开源中国（oschina)：https://my.oschina.net/action/xmlrpc 51cto：http://imguowei.blog.51cto.com/xmlrpc.php 网易（163）：http://os.blog.163.com/word/ typecho 博客：http://xx.com/action/xmlrpc，其中 xx.com 为你的博客网址。如果 typecho 还没有进行 url rewrite，则为 http://xx.com/index.php/action/xmlrpc 新浪博客： http://upload.move.blog.sina.com.cn/blog_rebuild/blog/xmlrpc.php 新浪博客的 API 已关闭了]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F11%2F17%2FJava%2F2018-03-12%2F</url>
    <content type="text"><![CDATA[# 1there is no default constructor available in BaseAdapter父类中没有可用的默认构造函数。这种情况下就需要显示的调用父类的构造方法， 毕竟有父类才有子类，通过父类的构造方法才能构造子类。因为 1234public BrandCountryRegionAdapter(Context context, int layoutId, List&lt;ReportProductArea&gt; datas) &#123; super(); int i = 1； &#125; 和 123public BrandCountryRegionAdapter(Context context, int layoutId, List&lt;ReportProductArea&gt; datas) &#123; int i = 1； &#125; 的内容是一样的，第二种写法是第一种的简写。 修正写法 1234public BrandCountryRegionAdapter(Context context, int layoutId, List&lt;ReportProductArea&gt; datas) &#123;+ super(context, layoutId, datas); int i = 1； &#125; 参考:http://blog.csdn.net/ozuijiaoweiyang/article/details/50477898 2attempting to use incompatible return type.尝试使用不兼容的返回类型。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F11%2F17%2FAndroid%2F2018-04-18-1_Unable%20to%20merge%20dex%2F</url>
    <content type="text"><![CDATA[“Unable to merge dex”问题解决今天在引用一个库UCrop时，报错： 123456Error:Execution failed for task ':cameraphotoframe:transformDexArchiveWithExternalLibsDexMergerForDebug'.&gt; java.lang.RuntimeException: com.android.builder.dexing.DexArchiveMergerException: Unable to merge dex翻译器：错误：执行失败的任务'：应用程序：转换Dex存档与外部库Dex合并调试'。&gt; java.lang.Runtime异常：java.lang.Runtime异常：com.android.builder.dexing.Dex归档合并异常：无法合并dex 原因是引入了重复的lib导致的：开始翻这个库的源码： 1234dependencies &#123; implementation 'com.android.support:appcompat-v7:27.1.0' implementation 'com.squareup.okhttp3:okhttp:3.8.1'&#125; 我的module 12compile 'com.github.yalantis:ucrop:2.2.2' implementation 'com.android.support:appcompat-v7:26.1.0' 然后删掉自己的的appcompat，重新编译，成功了！ 当你遇到这样的错误时，一定要先检查你的build.gradle是不是有重复的包 参考：https://stackoverflow.com/questions/46267621/unable-to-merge-dex?page=1&amp;tab=votes#tab-top 第二种情况All com. Android. Support libraries must use the exact same version specification (mixing versions can lead to runtime crashes). Found versions 27.1.0, 26.1.0. Examples include com. Android. Support: animated-vector-drawable:27.1.0 and com. Android. Support: design:26.1.0 more… (8 F1) This support library should not use a different version (27) than the compileSdkVersion (26) more.. (8 F1) compileSdkVersion 与com.android.support:design:$supportLibVersion” 的版本不一致。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F11%2F17%2FAndroid%2F2018-04-18-%E9%9A%90%E8%97%8F%E6%A0%87%E9%A2%98%E6%A0%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[隐藏标题栏的问题：继承了AppCompatActivity的Activity无法通过调用requestWindowFeature(Window.FEATURE_NO_TITLE)来隐藏标题栏。 12345678public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); //无效 setContentView(R.layout.activity_main); &#125;&#125; 既然这条路走不通，我就在AndroidManifest.xml将主题改为@android:style/Theme.NoTitleBar 12345&lt;application android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:theme="@android:style/Theme.NoTitleBar"//运行出错&gt; 在Android Monitor中看到错误报告：You need to use a Theme.AppCompat theme (or descendant) with this activity.（你必须使用Theme.AppCompat主题或者其子类主题） 解决方法：在AndroidManifest.xml中将主题更改为Theme.AppCompat.Light.NoActionBar、Theme.AppCompat.NoActionBar或Theme.AppCompat.DayNight.NoActionBar中的一个，即可隐藏标题栏 12345&lt;application android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:theme="@style/Theme.AppCompat.Light.NoActionBar"//成功隐藏标题栏&gt; 在activity中设置也可以 123456&lt;activity android:name=".CameraActivity" android:theme="@style/Theme.AppCompat.Light.NoActionBar" android:configChanges="orientation|screenLayout|keyboardHidden" android:hardwareAccelerated="true" android:screenOrientation="portrait"&gt; 或者直接修改style.xml文件 1234567891011121314&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name="Theme.MainActivity" parent="AppTheme"/&gt; &lt;style name="Theme.PreviewActivity" parent="Theme.AppCompat.NoActionBar"/&gt;&lt;/resources&gt; 123&lt;activity android:name=".PicturePreviewActivity" /&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 3中解决androidannotations报错]]></title>
    <url>%2FAndroid%2F2018%2F02%2F06%2FAndroid%2FAndroid%20Studio%203%E4%B8%AD%E8%A7%A3%E5%86%B3androidannotations%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[Android Studio 3中解决androidannotations报错报错最近Fork了一个项目，报以下错误12345Error:Execution failed for task ':sample:javaPreCompileDebug'.&gt; Annotation processors must be explicitly declared now. The following dependencies on the compile classpath are found to contain annotation processor. Please add them to the annotationProcessor configuration. - androidannotations-4.0.0.jar (org.androidannotations:androidannotations:4.0.0) Alternatively, set android.defaultConfig.javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true to continue with previous behavior. Note that this option is deprecated and will be removed in the future. See https://developer.android.com/r/tools/annotation-processor-error-message.html for more details. 解决方法在app目录下的gradle文件中添加 &#123;1234 annotationProcessorOptions &#123; includeCompileClasspath = true &#125;&#125; 变为 123456789101112131415161718android &#123; compileSdkVersion 25 buildToolsVersion "26.0.2" defaultConfig &#123; minSdkVersion 11 targetSdkVersion 25 versionCode 3 versionName "3.0.0" javaCompileOptions &#123; annotationProcessorOptions &#123; includeCompileClasspath = true &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>问题解决</tag>
        <tag>Android Studio</tag>
        <tag>androidannotations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 3中解决butterknife:7报错的问题]]></title>
    <url>%2FAndroid%2F2018%2F02%2F06%2FAndroid%2FAndroid%20Studio%203%E4%B8%AD%E8%A7%A3%E5%86%B3butterknife%3A7%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Android Studio 3中解决butterknife:7报错的问题最近从GitHub上Fork了一个项目任阅，用Android Studio3 打开后Android Studio 3.0中android-apt切换为官方annotationProcessor解决apt的问题后butterknife又有问题。 报错： 12345Error:Execution failed for task ':app:javaPreCompileDebug'.&gt; Annotation processors must be explicitly declared now. The following dependencies on the compile classpath are found to contain annotation processor. Please add them to the annotationProcessor configuration. - butterknife-7.0.1.jar (com.jakewharton:butterknife:7.0.1) Alternatively, set android.defaultConfig.javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true to continue with previous behavior. Note that this option is deprecated and will be removed in the future. See https://developer.android.com/r/tools/annotation-processor-error-message.html for more details. 解决办法：加上 annotationProcessor ‘com.jakewharton:butterknife:7.0.1’即可解决 12 compile 'com.jakewharton:butterknife:7.0.1'+ annotationProcessor 'com.jakewharton:butterknife:7.0.1' 参考：https://www.jianshu.com/p/09dc882a9fad]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>问题解决</tag>
        <tag>Android Studio</tag>
        <tag>butterknife</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 3.0中解决apt报错，android-apt切换为官方annotationProcessor]]></title>
    <url>%2FAndroid%2F2018%2F02%2F06%2FAndroid%2FAndroid%20Studio%203.0%E4%B8%AD%E8%A7%A3%E5%86%B3apt%E6%8A%A5%E9%94%99%EF%BC%8Candroid-apt%E5%88%87%E6%8D%A2%E4%B8%BA%E5%AE%98%E6%96%B9annotationProcessor%20%2F</url>
    <content type="text"><![CDATA[Android Studio 3.0中解决apt报错，android-apt切换为官方annotationProcessor最近从GitHub上Fork了一个项目任阅，用Android Studio3 打开后 报错1234567891011121314151617181920212223242526Error:Cannot choose between the following configurations of project :EasyAdapterLibrary: - debugApiElements - debugRuntimeElements - releaseApiElements - releaseRuntimeElementsAll of them match the consumer attributes: - Configuration 'debugApiElements': - Found com.android.build.api.attributes.BuildTypeAttr 'debug' but wasn't required. - Found com.android.build.gradle.internal.dependency.AndroidTypeAttr 'Aar' but wasn't required. - Found com.android.build.gradle.internal.dependency.VariantAttr 'debug' but wasn't required. - Found org.gradle.api.attributes.Usage 'java-api' but wasn't required. - Configuration 'debugRuntimeElements': - Found com.android.build.api.attributes.BuildTypeAttr 'debug' but wasn't required. - Found com.android.build.gradle.internal.dependency.AndroidTypeAttr 'Aar' but wasn't required. - Found com.android.build.gradle.internal.dependency.VariantAttr 'debug' but wasn't required. - Found org.gradle.api.attributes.Usage 'java-runtime' but wasn't required. - Configuration 'releaseApiElements': - Found com.android.build.api.attributes.BuildTypeAttr 'release' but wasn't required. - Found com.android.build.gradle.internal.dependency.AndroidTypeAttr 'Aar' but wasn't required. - Found com.android.build.gradle.internal.dependency.VariantAttr 'release' but wasn't required. - Found org.gradle.api.attributes.Usage 'java-api' but wasn't required. - Configuration 'releaseRuntimeElements': - Found com.android.build.api.attributes.BuildTypeAttr 'release' but wasn't required. - Found com.android.build.gradle.internal.dependency.AndroidTypeAttr 'Aar' but wasn't required. - Found com.android.build.gradle.internal.dependency.VariantAttr 'release' but wasn't required. - Found org.gradle.api.attributes.Usage 'java-runtime' but wasn't required. 原因从Messages中并没有查看出是什么原因，但是此项目之前使用的AS2.1，并且gradle中使用了apt，所以我怀疑是Studio升级到3.0之后原来的配置方式apt与最新版本Gradle已经不兼容。 APTAPT(Annotation Processing Tool)是一种处理注释的工具,它对源代码文件进行检测找出其中的Annotation，使用Annotation进行额外的处理。Annotation处理器在处理Annotation时可以根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由Annotation处理器的编写者决定),APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件。 Android Gradle插件2.2版本发布后，Android 官方提供了annotationProcessor来代替android-apt，annotationProcessor同时支持 javac 和 jack 编译方式，而android-apt只支持 javac 方式。同时android-apt作者宣布不在维护，当然目前android-apt仍然可以正常运行，如果你没有想支持 jack 编译方式的话，可以继续使用 android-apt。Android Studio 3.0执行android-apt报错： Android Studio 3.0执行android-apt一般会报错： 1Error:android-apt plugin is incompatible with the Android Gradle plugin. Please use 'annotationProcessor' configuration instead. 解决android-apt切换为官方annotationProcessor的方法 1、 在build.gradle修改为Android Gradle 3.0 插件 1234567891011buildscript &#123; repositories &#123; ... google() &#125;- classpath 'com.android.tools.build:gradle:2.1.0'+ classpath 'com.android.tools.build:gradle:3.0.1' &#125;&#125; 2、删除build.gradle里android-apt 的相关配置 项目目录下 123456789101112 buildscript &#123; repositories &#123; maven&#123; url 'http://maven.aliyun.com/nexus/content/groups/public/'&#125; jcenter() &#125; dependencies &#123;- classpath 'com.android.tools.build:gradle:2.1.0'- classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'+ classpath 'com.android.tools.build:gradle:3.0.1'+ // classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' &#125; &#125; app目录下 plugin: 'com.android.application'123456- apply plugin: &apos;android-apt&apos;+ //apply plugin: &apos;android-apt&apos; android &#123; compileSdkVersion 23 buildToolsVersion &quot;23.0.3&quot; 3、替换build.gradle里旧的配置为新的配置 做以下替换 compile 改为 implementation, apt 改为 annotationProcessor testCompile 改为 androidTestImplementation app目录下 'com.squareup.okhttp3:okhttp:3.2.0'12345678 // Annotation- compile &apos;com.google.dagger:dagger:2.0.2&apos;- apt &apos;com.google.dagger:dagger-compiler:2.0.2&apos;+// compile &apos;com.google.dagger:dagger:2.0.2&apos;+// apt &apos;com.google.dagger:dagger-compiler:2.0.2&apos;+ implementation &apos;com.google.dagger:dagger:2.9&apos;+ annotationProcessor &apos;com.google.dagger:dagger-compiler:2.9&apos;+ 4、清理缓存并重启Android Studio 3.0 5 扩展同样适用于一下报错信息的解决 1Error:android-apt plugin is incompatible with the Android Gradle plugin. Please use 'annotationProcessor' configuration instead. 参考：https://www.jianshu.com/p/c1666a947692https://majing.io/posts/10000003001155]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>问题解决</tag>
        <tag>Android Studio</tag>
        <tag>apt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RelativeLayout、Framelayout 两布局重叠,使下层不响应点击事件]]></title>
    <url>%2FAndroid%2F2018%2F01%2F23%2FAndroid%2FRelativeLayout%E3%80%81Framelayout%20%E4%B8%A4%E5%B8%83%E5%B1%80%E9%87%8D%E5%8F%A0%2C%E4%BD%BF%E4%B8%8B%E5%B1%82%E4%B8%8D%E5%93%8D%E5%BA%94%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[RelativeLayout、Framelayout 两布局重叠,使下层不响应点击事件123456789101112131415161718192021222324252627282930代码段A&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ListView android:id="@+id/listview" android:layout_width="match_parent" android:layout_height="match_parent" android:divider="@null" android:fadingEdge="none" android:listSelector="@android:color/transparent" android:scrollbars="none" /&gt; &lt;LinearLayout android:id="@+id/search_container" android:layout_height="match_parent" android:layout_width="match_parent" android:visibility="gone" android:orientation="vertical" android:background="@android:color/darker_gray"&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; FrameLayout、RelativeLayout，代码中控件代码的的位置越靠后，此控件越会显示在层叠布局的上方。 代码段B的布局会动态加载到代码段A的search_container中，并且形成重叠布局，此时 markView 会遮盖listView，但是点击事件会穿透markView传递给listView。 123456789101112131415代码段B&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;View android:id="@+id/markView" android:layout_width="match_parent" android:layout_height="match_parent" android:alpha="0.5" android:background="@color/black" /&gt;&lt;/LinearLayout&gt; 怎样解决这个问题呢？ 代码段B 增加一行代码 android:clickable=&quot;true&quot; 变成这样123456789101112131415代码段C&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:clickable="true" android:orientation="vertical" &gt; &lt;View android:layout_width="match_parent" android:layout_height="match_parent" android:alpha="0.5" android:background="@color/black" /&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用GitBook制作一本书（从GitHub导入创建一本书）]]></title>
    <url>%2FGit%2F2018%2F01%2F12%2FVersionControl%2F2018-01-12%2F</url>
    <content type="text"><![CDATA[1创建一个Github Repositoryhttps://github.com/new 2创建一本书https://www.gitbook.com/new 选择从Github导入2.Github授权 3 导入Github Repository作为书籍再次回到https://www.gitbook.com/new， 填写Book信息，选择你要导入的Github Repository 这个页面目前是在同步，等同步完毕后，就可以看到自己的书了。 4去编辑自己的书吧可以在浏览器编辑，也可以在客户端编辑 参考：http://blog.csdn.net/hk2291976/article/details/51173850]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitBook</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac和Linux返回上一级的命令是什么]]></title>
    <url>%2FMac%2F2018%2F01%2F12%2FMac%2F2018-01-11%2F</url>
    <content type="text"><![CDATA[Mac和Linux返回上一级的命令是什么要注意在linux shell有几个特定的符号。一个就是 . 指当前目录，例如： sh ./xx就是用shell去运行当前目录下的xx程序。一个是 .. 指上一级目录，例如： vi ../xx就是用vi去打开上一级目录下的xx文件。 cd ..将上一级目录变为当前目录，也就是返回上一级。另外就是 ~ 代表当前用户的家目录。 cd ~回到登录用户的家目录。参考：https://zhidao.baidu.com/question/58838894]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>命令行</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo创建文章和草稿]]></title>
    <url>%2FReactNative%2F2018%2F01%2F12%2FReactNative%2F2018-01-12%2F</url>
    <content type="text"><![CDATA[JavaScript语法let以及let与var的区别let 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。 语法let var1 [= value1] [, var2 [= value2]] [, …, varN [= valueN]]; 参数var1, var2, …, varN 变量名。可以是任意合法的标识符。 value1, value2, …, valueN 变量的初始值。可以是任意合法的表达式。 描述let允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与var关键字不同的是，它声明的变量只能是全局或者整个函数块的。 这里解释了我们为什么选取“let”这个名字。 12345678Let is a mathematical statement that was adopted by early programming languages like Scheme and Basic. Variables are considered low level entities not suitable for higher levels of abstraction, thus the desire of many language designers to introduce similar but more powerful concepts like in Clojure, F#, Scala, where let might mean a value, or a variable that can be assigned, but not changed, which in turn lets the compiler catch more programming errors and optimize code better. JavaScript has had var from the beginning, so they just needed another keyword, and just borrowed from dozens of other languages that use let already as a traditional keyword as close to var as possible, although in JavaScript let creates block scope local variable instead. answered Jun 20 ‘16 at 7:47 exebook 123456Let是一个数学声明，是采用于早期的编程语言如Scheme和Basic。变量被认为是不适合更高层次抽象的低级实体，因此许多语言设计者希望引入类似但更强大的概念，如在Clojure、f#、Scala，let可能意味着一个值，或者一个变量可以赋值，但不能被更改，这反过来使编译器能够捕获更多的编程错误和优化代码更好。javascript从一开始就有var，所以他们只是需要另一个关键字，并只是借用了其他数十种语言，使用let已经作为一个传统的尽可能接近var的关键字，虽然在javascript 中 let只创建块范围局部变量而已。 作用域规则let声明的变量只在其声明的块或子块中可用，这一点，与var相似。二者之间最主要的区别在于var声明的变量的作用域是整个封闭函数。 1234567891011121314151617function varTest() &#123; var x = 1; if (true) &#123; var x = 2; // 同样的变量! console.log(x); // 2 &#125; console.log(x); // 2&#125;function letTest() &#123; let x = 1; if (true) &#123; let x = 2; // 不同的变量 console.log(x); // 2 &#125; console.log(x); // 1&#125; 简化内部函数代码当用到内部函数的时候，let会让你的代码更加简洁。 1234567891011121314151617181920212223242526var list = document.getElementById('list');for (let i = 1; i &lt;= 5; i++) &#123; let item = document.createElement('li'); item.appendChild(document.createTextNode('Item ' + i)); item.onclick = function(ev) &#123; console.log('Item ' + i + ' is clicked.'); &#125;; list.appendChild(item);&#125;// to achieve the same effect with 'var'// you have to create a different context// using a closure to preserve the valuefor (var i = 1; i &lt;= 5; i++) &#123; var item = document.createElement('li'); item.appendChild(document.createTextNode('Item ' + i)); (function(i)&#123; item.onclick = function(ev) &#123; console.log('Item ' + i + ' is clicked.'); &#125;; &#125;)(i); list.appendChild(item);&#125; 以上示例的工作原理是因为（匿名）内部函数的五个实例引用了变量i的五个不同实例。注意，如果你将let替换为var，则它将无法正常工作，因为所有内部函数都将返回相同的i：6的最终值。此外，我们可以通过将创建新元素的代码移动到每个循环的作用域来保持循环更清晰。 在程序或者函数的顶层，let并不会像**var**一样在全局对象上创造一个属性，比如： 1234var x = 'global';let y = 'global';console.log(this.x); // "global"console.log(this.y); // undefined 模仿私有接口在处理构造函数的时候，可以通过let绑定来共享一个或多个私有成员，而不使用闭包： 123456789101112131415161718192021222324252627282930313233343536var Thing;&#123; let privateScope = new WeakMap(); let counter = 0; Thing = function() &#123; this.someProperty = 'foo'; privateScope.set(this, &#123; hidden: ++counter, &#125;); &#125;; Thing.prototype.showPublic = function() &#123; return this.someProperty; &#125;; Thing.prototype.showPrivate = function() &#123; return privateScope.get(this).hidden; &#125;;&#125;console.log(typeof privateScope);// "undefined"var thing = new Thing();console.log(thing);// Thing &#123;someProperty: "foo"&#125;thing.showPublic();// "foo"thing.showPrivate();// 1 let暂存死区的错误在相同的函数或块作用域内重新声明同一个变量会引发SyntaxError。 1234if (x) &#123; let foo; let foo; // TypeError thrown.&#125; 在 ECMAScript 2015 中，**let**绑定不受变量提升的约束，这意味着**let**声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前，引用它将会导致 [ReferenceError](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError)（而使用 var 声明变量则恰恰相反，该变量的值是 undefined ）。该变量处于从块开始到初始化处理的“暂存死区”。 123456function do_something() &#123; console.log(bar); // undefined console.log(foo); // ReferenceError: foo is not defined var bar = 1; let foo = 2;&#125; 在 switch 声明中你可能会遇到这样的错误，因为它只有一个块. 123456789switch (x) &#123; case 0: let foo; break; case 1: let foo; // TypeError for redeclaration. break;&#125; 但是，重要的是要指出嵌套在case子句内的块将创建一个新的块作用域的词法环境，这不会产生上面显示的重新声明错误。 123456789101112let x = 1;switch(x) &#123; case 0: &#123; let foo; break; &#125; case 1: &#123; let foo; break; &#125;&#125; 与词法作用域结合的暂存死区由于词法作用域，表达式(foo + 55)内的标识符“foo”会解析为if块的foo，而不是覆盖值为33的foo。在这一行中，if块的“foo”已经在词法环境中创建，但尚未达到（并终止）其初始化（这是语句本身的一部分）：它仍处于暂存死区。 1234567function test()&#123; var foo = 33; if (true) &#123; let foo = (foo + 55); // ReferenceError &#125;&#125;test(); 这种现象可能会使您陷入以下情况。指令let n of n.a已经在for循环块的私有范围内，因此标识符“n.a”被解析为位于指令本身的第一部分（“let n”）中的’n’对象的属性’a’ ，由于尚未达成和终止其声明，因此仍处于暂存死区。 12345678910function go(n) &#123; // n here is defined! console.log(n); // Object &#123;a: [1,2,3]&#125; for (let n of n.a) &#123; // ReferenceError console.log(n); &#125;&#125;go(&#123;a: [1, 2, 3]&#125;); 其他情况当在块中使用时，let将变量的作用域限制为该块。注意**var**的作用域在它被声明的函数内的区别。 12345678910111213var a = 1;var b = 2;if (a === 1) &#123; var a = 11; // the scope is global let b = 22; // the scope is inside the if-block console.log(a); // 11 console.log(b); // 22&#125; console.log(a); // 11console.log(b); // 2 规范| Specification | Status | Comment || ECMAScript 2015 (6th Edition, ECMA-262) Let and Const Declarations | Standard | Initial definition. Does not specify let expressions or let blocks. || ECMAScript Latest Draft (ECMA-262) Let and Const Declarations | Living Standard | | 浏览器兼容 Desktop Mobile Feature Chrome Edge Firefox Internet Explorer Opera Safari Basic support 41 12 441 2 3 11 17 10 1. Prior to Firefox 44, let is only available to code blocks in HTML wrapped in a &lt;script type=&quot;application/javascript;version=1.7&quot;&gt; block (or higher version) and has different semantics (e.g. no temporal dead zone). 2. Prior to Firefox 46, a TypeError is thrown on redeclaration instead of a SyntaxError. 3. Firefox 54 adds support of let in workers. 相关链接 var const ES6 In Depth: let and const Breaking changes in let and const in Firefox 44. You Don’t Know JS: Scope &amp; Closures: Chapter 3: Function vs. Block Scope 文档标签和贡献者 标签： ECMAScript 2015 JavaScript let Statement Variable declaration Variables 参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ECMAScript 2015</tag>
        <tag>JavaScript</tag>
        <tag>let</tag>
        <tag>Statement</tag>
        <tag>ES6</tag>
        <tag>Variable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ListView的Item会出现点击两次的问题]]></title>
    <url>%2FAndroid%2F2018%2F01%2F10%2F2018-01-10%2F</url>
    <content type="text"><![CDATA[Android ListView的Item会出现点击两次的问题方案有两种，方案一： 直接自定义监听器，适用于大量此类操作。方案二： 直接在方法里拦截，适用于少量此类操作。 方案一：自定义一个监听器NoDoubleClickListener，抽象一个 onNoDoubleClick 方法。 1234567891011121314151617public abstract class NoDoubleClickListener implements View.OnClickListener &#123; public static final int DELAY = 10000; //连击事件间隔 private long lastClickTime = 0; //记录最后一次时间 @Override public void onClick(View v) &#123; long currentTime = System.currentTimeMillis(); if (currentTime - lastClickTime &gt; DELAY) &#123; //判断时间差 lastClickTime = currentTime; //记录最后一次点击时间 onNoDoubleClick(v); &#125; &#125; //抽象一个无连击事件方法，用于实现内容 public abstract void onNoDoubleClick(View v);&#125; 用法，在建立监听的时候使用刚刚自定义的监听器，并实现其抽象方法。 1234567view.setOnClickListener(new NoDoubleClickListener() &#123; @Override public void onNoDoubleClick(View v) &#123; //你的代码 &#125; &#125;); 方案二：把方案一的时间差判定方法拿出来。。就行了。。 1234567891011public class Utils &#123; public static final int DELAY = 1000; private static long lastClickTime = 0; public static boolean isNotFastClick()&#123; long currentTime = System.currentTimeMillis(); if (currentTime - lastClickTime &gt; DELAY) &#123; lastClickTime = currentTime; return true; &#125;else&#123;return false;&#125; &#125;&#125; 用法, 12345678view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if(Utils.isNotFastClick())&#123; //你的代码 &#125; &#125; &#125;); 按照java的设计原则，推荐第一种方案。其他监听也是同样的自定义方式。 参考：https://segmentfault.com/q/1010000004395999]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员应该知道的10种软件]]></title>
    <url>%2F%E7%A8%8B%E5%BA%8F%E5%91%98%2F2018%2F01%2F04%2FProgrammer%2F2018-01-04%2F</url>
    <content type="text"><![CDATA[程序员应该知道的10种软件除非你是设计小型模拟电子电路，不然这年头离开了计算机的帮助，在嵌入式系统设计中很难做成什么事。我觉得我应该分享一个能帮助我完成工作的软件工具列表。它们大多数都是免费的或者比较便宜的。它们大多数也和软件一起工作。如果你向来不需要设计，阅读或者编辑任何软件，那么你属于读了这篇文章不会从中受益的那一小部分人。 免责声明：“最佳”软件工具通常是一种主张。你可能不同意我的主张，那就取其精华吧。 1. 版本控制不管你工作在一个100人的团队，还是独自一人干活，如果你从事设计，你应该会用到版本控制软件。这是一种可以管理文档的不同版本的软件，不管是图表还是源代码。像源代码或配置文件这样的文本文档尤其适合于版本控制，因为很容易查看版本间的差异，合并两个版本之间的改动，特别是多个人工作在一组文档上。 版本控制里的文档集合称为版本库（repository）。版本库所在的位置某种程度上取决于你用什么样的版本控制系统——基本上有两类版本控制系统：集中式和分布式。集中式版本控制包含一个存放版本库的服务器。当你方便的时候，你提交你的修改到版本库里。分布式版本控制系统（DVCS）不需要中央服务器：每个人工作在有他们自己的本地缓存的版本库上（包括整个历史记录），可能会从一个版本库传送新的提交到另一个版本库，通过在原版本库上“push”或者在目标版本库上“pull”完成。 2012年开源社区里最流行的三个版本控制系统是Subversion（SVN），Mercurial（hg）和Git。Subversion是集中式的，而Mercurial和Git是分布式的。 我用Mercurial开发个人软件。建立版本库很简单。到你工作的根目录下输入hg init，然后用hg add添加你喜欢的文件，然后用hg commit提交。我只需要花几分钟，立马就能够回退到某个文件的早期版本。我会专门为我家里PC机上的服务配置文件（例如Apache网站服务器）这样做——如果我修改了一个文件，并且这个修改引起了一个bug，我只用回退到该文件的早期版本就可以了。 如果项目只有你一个人在做，管理版本控制系统容易得不可思议——只需要在较好的暂停点时不时进行提交。如果你和别人一起工作，当你们中的一个人做出修改而另一个人做出不同的修改产生冲突时，有几种方法来协调。就是所谓的“合并”。对于文本文档，只要你经常这样做，通常很容易。对于二进制文件，几乎不可能。比较合适的处理方式是在库里的文件上放置一道锁，清楚地声明你工作在一个特殊的文件上，并且其他人不应该工作在这个文件上。 这三个系统（svn，hg和git）起先全都是命令行工具，但是它们都有各式各样的图形用户界面前端，包括Tortoise系列的用户界面。那是一个在你的操作系统的文件浏览器（如Windows Explorer或者Mac OSX Finder）上扩展的轻量级组件。它们不如非免费的版本控制系统那样易用。我们工作中用过SurroundSCM，当我有点不太喜欢后端的行为方式时，我发现Surround UI在协调分支间的差异上更加好用。 还值得注意的是有很多版本库在线主机系统，有bitbucket.org，SourceForge，Google Code和GitHub。它们全都为公开版本库提供免费的主机服务。bitbucket免费为项目成员不超过5人的私有版本库提供主机服务。我强烈推荐使用像Mercurial或者Git这样的分布式版本控制系统，因为这意味着你可以把项目从一个主机站点转到另一个上，并且即使站点临时宕机，你依旧可以使用本地的版本库的拷贝。 2. 文件比较工具在将代码合并到版本控制系统中，或者仅仅是想看看一个文件同另一个文件之间的差异时，你会需要文件比较工具。有命令行的工具如“diff”，还有图形用户界面的文件比较工具。我喜欢叫Beyond Compare的程序——不是免费的，但是不贵，并且易用。它还可以比较两个文件夹，可以让你做3-way文件比较。Beyond Compare有Windows和Linux的，OSX版本的正在开发但是现在还没有。其他的还有SourceGear DiffMerge（免费，跨平台 Win/OSX/Linux），Compare It!（便宜，只有Windows的），DeltaWalker（价格适中，OSX）和UltraCompare（价格适中，跨平台）。 3. 编辑器和文本文件打交道可难可易，这取决于你用的软件。重量级的编辑器是像Eclipse，NetBeans或者Visual Studio那样的集成开发环境（IDE）。假如你用特定的软件工具和在特殊的处理器上编程，那么它们很出色。但是有时候你需要的只是快速编辑文件。操作系统自带的基本编辑器（像Windows上的记事本，Mac上的TextEdit）是轻量级的，但他们没有多少功能。我喜欢有中量级的编辑器可以用：这个类目里有一些好的免费编辑器，如Windows上的Notepad++，Mac上的TextWrangler。我还用过非免费的UltraEdit，它更强大一点，而且在Windows，OSX，Linux上都可以用。SlickEdit是专业级的编辑器，要价数百美元，可能对绝大多数任务杀伤力过大，但我的一些同事却很忠于它。（希望他们没有吐槽它） 提到编辑器不提GNU emacs就不公平了——它是免费的开源的编辑器，诞生于当大多数操作系统还是基于终端的时候。它的大多数命令都是用一串难以理解的按键发出。你喜欢这样的方式就行，我是不喜欢的。它是一个非常强大的编辑器，可以通过Lisp语言编程定制。你可以在emacs里做任何事，只要它是可以在终端显示的。 我要找的编辑器的两大功能如下： 大文件支持。如果很大的文件（若干兆），确保你的编辑器可以在不用把文件全部加载到内存就能打开它。记事本不行，但是Notepad++和UltraEdit可以。 “多文件查找”功能 典型的源代码树包含多个文件，你经常会忘记把东西放哪了。（好吧，至少我会忘记把东西放哪了！）在多个文件里搜索一个单词或模式的能力是无价的。Unix的“grep”允许你用命令行做这样的事，但是编辑器里的“多文件查找”功能可以让你双击查找结果，然后跳到编辑器里的该行上。 你可能还需要在十六进制编辑器里编辑二进制文件——可以让你查看和编辑那些不可打印字符的字符码。Notepad++和UltraEdit都有十六进制编辑模式。如果你用Mac，试试单机版的Hex Fiend——它很不错。 还有用于XML文件的特殊编辑器——在免费类目里，有XML Notepad和firstobject的XML编辑器“foxe”。foxe的用户界面有点笨拙，但是用来编辑大型文件非常非常不错。 4. Build 工具如果你开始在IDE里写软件，只用点击”构建“，然后程序就给你编译你的源代码。这样做要注意，它意味着你在让IDE去操心那些细节。对于你正在其中学习某个东西的小系统倒还好。但是有大量的选项可以改变软件的编译方式，在IDE里它们被埋藏在菜单里，并且也不容易从一个项目转移到另一个项目。运气好的话，你可以识别出用于存储构建配置的那些文件，然后可以检入到版本控制系统，因为不然的话你保存的不是完整的项目源码。 专业的软件工程师——重申，这是一家之言——应该用一种明确的构建工具。标准的原味的（plain-vanilla）解决方案（我宁愿错打成痛苦味的pain-vanilla，并这样保持下去）是一个在70年代引入的叫做make的程序。不幸的是它现在仍被在用。makefile由像这样若干行构成： foo.obj: foo.ccc -o $@ $&lt; 它们是一些规则，告诉make如何通过执行程序（这个例子里是“cc”）把源文件（例如上面的“foo.c”）变成目标文件（例如“foo.obj”）来构建你的软件。它们还指示依赖关系：假设文件F3依赖于运行命令X从文件F2生成文件F3，文件F2依赖于运行命令Y从文件F1生成文件F2——构建工具要能够推断出依赖关系图，这样如果你改变了文件F1，它能够知道必须相应地重新构建文件F2和文件F3。这可能看起来微不足道，但是在任何项目里，除了那种微型软件项目，这都是相当重要的。我从事的是相对简单的软件项目，它只有数十个源文件，但是全部编译需要5分钟。有合适的构建工具正确的捕获依赖关系，根据你做的修改，让你只增量编译那些有需要的文件。 make有很多短板。别的不说，makefile的语法很含糊，你在编译时需要做特殊处理的地方，它难以处理这种特殊情况，你不去为此写一些单独的脚本是不行的。 对于Java程序而言，标准工具是ant和maven。它们让事情更容易，还可以用来构建Java程序之外的其他系统，但是在一般开发环境下不经常用到。 还有很多其他的构建工具。过去的几年里，我开始将我的偏好从陈述性语法（如makefile和ant脚本）的工具转移到更加多用途的语法的工具上。这样的想法是因为对于大多数简单的任务，你可以描述得非常简明，但是如果你想要做点复杂的事，你拥有多用途编程语言的全部威力。（举个例子，如果你想在一个特殊的构建任务里启用命令行选项“-On”，这里“n”是一个数字，等于文件的大小模以7。你可以写一个自动做这个的方法）这些工具包括rake（基于Ruby），gradle（基于Groovy），scons和waf（它俩都基于Python）。我用了scons三年，因为我懂Python。是一个同事给我推荐的scons。它在某些地方工作的很好，并且极其灵活，但是在其他地方真的难以去修改scons的默认行为，让它做你真正要做的。最近我刚开始用waf。我发现更容易让它做我需要做的，因此如果你有一个新项目，我推荐你看看waf，尽管我希望它有一个不这么神秘的名字。 5. 脚本工具有时候你需要快速组装一段软件来做某件事。通常很难用C或者C++来实现，因为你必须花费精力写代码来解析字符串，或者读文件，或者任何别的什么。然后你得为每个计算机平台把这个C/C++程序编译成可执行文件。啊… 更好的解决方案是使用脚本语言。它们通常都是解释性的计算机语言，解释器提供了大多数操作系统的版本。所以如果你写了一个脚本，应该可以用在不同的操作系统上。 现代脚本语言的例子是Python，Ruby和Groovy。（我更喜欢Python。）早期的脚本语言包括awk和Perl。我有一些避免使用Perl的理由：它的语法非常奇特和神秘，不同的类型有不同的前缀（$foo是一个单变量，但是@foo是一个数组），还有它鼓励使用“伪变量”（&lt;&gt;和$_），它的一些副作用隐含地依赖于程序里其他被执行的动作。这些造就了不良的编程风格：编写简短而神秘的脚本，它可以用几行标点符号聪明地完成一些事，但是别人阅读和维护都不易。我惭愧地承认10年前我大量使用awk，因为它比perl简单。awk是一种古老的文本处理脚本语言，曾经有它的地位，但是在某些角度和Perl一样糟糕，都鼓励不好的编程实践。 不管你喜欢哪个，我会强烈建议你用一种能够在调试器里测试的语言。我用awk的经历很糟糕，调试程序的时候我不得不放一些打印语句在里面，告诉我发生什么了。用Python就很开心，因为有一个很好的Eclipse的插件叫做pydev。用它你可以在脚本任何地方设置断点和单步调试。 我时不时也用一个叫做JSDB的程序。JSDB是一个独立的JavaScript的外壳程序，用创立于Firefox网页浏览器的SpiderMonkey JavaScript引擎构建。它还有一些访问文件，数据库，网络流和串行端口等等的工具类。它没有解释性的调试器（尽管有一个奇怪的调试器。该调试器有一种即时网络服务器，你可以把你的网页浏览器指向你计算机上的一个端口，它就可以让你调试程序），并且有时候有一点诡异，但是它比起Python更轻量级，对于有些事情，我发现我能更快着手。 我在这节所提到的所有脚本语言都是免费的。 6. 数值分析工具 除非你做的东西像能够联网的交通灯这种真的很简单，否则有这种可能就是你在嵌入式系统项目里的做某种数学部分。你也许要给数据作图，或者为数据拟合曲线，或者解方程，或者设计一个低通滤波器，或者观察当你修改参数后你的系统改变了多少。在这些任务上数值分析工具可以帮到你。它们包括MATLAB，Mathematica，和MathCAD这样的程序。它们都不是免费的。完全版的MATLAB还有它的全套工具箱会花掉你数千美元，不过它们提供了大量的功能。MATLAB擅长于数据分析，Mathematica擅长符号代数。MathCAD介于两者之间，是所见即所得的处理方式：用来得到你在MathCAD的工作表（worksheet）里所见到的输出的每个运算，在该工作表上你都能看到。因此它一目了然。如果你给谁打印这个工作表，他/她能看到要去复制你的工作成果所需的所有计算步骤。例如和Excel工作表比较，你看到的是运算的结果。要想看的运算步骤，你需要到每一个单元格里去看是否有公式。 MATLAB也有一些“山寨”免费软件：SciLab，Octave和PyLab。它们都提供了MATLAB提供的基本功能，语法也要么一样，要么很相似。但是没有一个像MATLAB那样优美和专业。PyLab的额外的卖点是用Python语言实现，还有为Python提供了科学计算和作图的库。因此如果你懂Python，你可以利用这些知识去进行科学计算。 我对MATLAB是爱恨交加的关系。一方面，它是如此美丽的软件，让你做数值分析，可视化，还有额外的包罗万象的工具箱（信号处理，滤波器设计，控制回路仿真，等等）。另一方面，它不便宜，在MathWorks里的那些出售MATLAB的人们在炫耀他们最新的功能时乐呵呵的好像价格是不需要考虑的。 关于数值分析工具，我有最后一句恳求的咆哮体 不要用Excel进行数值分析！！！ 1996年我开始工作时还是一个电气工程师，我还不懂MATLAB，所以当我要给数据作图时，我用我所知道的：微软Excel。Excel是主要针对商业应用的电子表格软件，但是它可以读文字分割文件（如逗号分隔值CSV文件），有某种控制绘图的方式能让你给结果作图，因此它可以用于给数据图像化。但是如果要做任何超出基本绘制的事情，你会发现要这样非常困难，并且很快就会令人沮丧。如果你有一组数据要图像化，或许不是那么糟糕，而且你可以交互式的让它变成你想要的样子。如果你有一批数据文件想要用同样的方式绘图，真的是个很大的麻烦，你要手动地反反复复去做同样的事情直到结束。当然，你可以用Visual Basic编写宏代码。当我想要在一个页面上做多个图，并对齐坐标轴时我就这么做过。但是接着你会发现你所知道的对象模型既变态又古怪，可能不能让你做你想要做的。然后你便开始对住在华盛顿雷德蒙的某些人起了坏念头。在Excel里如果你遇到了要写宏代码的时候，停下来想想你的情况。那些你投入在让Excel做你要做的事情的时间，你可以花在学习其他能更容易绘图和分析数据的，用于科研而不是商业的软件上。记住，在微软的那些人试图制作能销售和上市的软件，人们用这样的软件可以解决他们的问题。而作为工程师，我们得到的不管什么样的功能刚好是在给自己增加困难。 7. 文档工具你经常会和其他人交流你的想法，有很多不同类型的软件可以帮助你做这个。是的，有不免费的微软程序像用于流程图/绘图的Visio，写文档的Word，还有演讲用的PowerPoint。但是有时候你想要免费的或者更专门的东西，用于特殊类型的文档。 图形可视化 我们不是在此谈x-y图，而是能够可视化带有节点和边的网络。我用graphviz（基于命令行的）和yEd（交互式的）。这两个我都推荐。 序列图 他们让你可视化用例，即一串引起软件组件交互的事件。Quick Sequence Diagram Editor是一个很基本而又可以帮助你画这些图的工具。 “排版”工具（不是生产文档的所见即所得的软件）——docutils和sphinx都能根据ReStructured Text（一种维基风格的标记语言）生成Python风格的文档。所需的生成代码文档的工作量是很少的，尽管两者都能为Python缩进，将它们用于任何其他文档也不难。我前不久放弃了Tex和LaTex，但那是我个人的怪癖，这两个在科研圈子里大量用到。所以你能在那里找到很多支持。还有DocBook。或者你可以寻求所见即所得软件，但是要小心。 “自文档化”代码工具：Doxygen是其中最常见的，把你代码里的注释转为文档。Javadoc是专门用于Java的文档工具。 8. 终端和通讯软件：当你需要经由串口通讯时，到了该用终端软件的时候了。在网页浏览器之前，这更加常见。哪个软件好？朋友不会让朋友使用绑定Windows的超级终端版本——它不是那么健壮——而且微软最终发布Vista时不再捎上它了。我最喜欢的是PuTTYtel和TeraTerm Pro。 其他通讯软件处理FTP和其安全变种SFTP以及SCP。照我看Cyberduck无疑是胜者——非常易用，最开始只在Mac上，现在OSX和Windows上都有。（此外，你如何能不喜欢上一个将橡皮鸭作为logo的软件呢） 9. 软件质量保证（QA）工具：如果你写软件，并认为自己的软件没有bug的，那是自己骗自己。有很多软件工具可以帮你在bug找你之前先找到它们。好了，此处我不得不承认我还只是个新手，我还不是特别熟悉这块有些什么。（太不好意思了！）但是我确实足够了解该建议看什么地方。一些主要的类别如下： 静态分析工具。这类软件解析你的软件，或者通过未处理的源码，或者通过编译后的对象文件。最著名的例子是C的lint。lint像是你高中的英语老师，他/她在你的试卷上到处画红叉，抱怨你用“who”代替了“whom”，或者句子里你用的介词结尾。要用英语有效地交流，你用得着严格遵循这些规则吗？不，但是这样做有助于你预防错误。C语言里也是如此——避免写某种差劲的模式的代码可以帮助你预防错误，而lint是帮你找到那些模式的。Java有FindBugs，而其他的编程语言也有类似的程序。在这类软件里同样会计算代码复杂度——好的软件设计通常使函数保持短小。如果你发现你写的函数超过20-30行，你或许可以把它们分成更小的单元，这样更容易设计和调试。 单元测试和代码覆盖率。通常认为测试大型软件包是及其困难的，而在单个代码模块上写尝试各种输入模式的单元测试来测试较小的软件模块比较容易。在嵌入式系统里单元测试可以很难。一种方法是在PC上交叉编译软件，并寄希望于你的软件里的任何bug可以在PC编译版本里被检测到。当你能够写自动测试脚本也是有希望的。这样当你对你的软件做了修改，你可以运行自动测试脚本，检查是否引入了新bug。对于代码覆盖率，我在医疗工业里的同事使用Cantata++。它不便宜，但是这些可是医疗设备。 代码“美化器”——如果你和同事都使用相同的代码，那你可以更容易的找到低级的语法bug。正常情况我们都有自己的风格，但是这里就有软件可以自动缩进，把制表符转为空格或等价的东西。我考虑过的有一个叫做Uncrustify，附有一个图形用户界面叫做UniversalIndentGUI。 （推荐阅读伯乐在线之前的这篇文章《代码美化与格式化工具》） 10. 基本命令行应用工具下面的很多程序都是UNIX的命令行应用工具，它们出生在还没有图形用户界面，事情都需要靠手动去完成的日子。除非现在图形用户界面有革命性的改进，否则通过命令行，你能做的总是更多些，因为你通过脚本可以完成更多种事情的组合。如果你运行的是OSX或者Linux，你已经有这些工具了。如果你运行的是Windows，你可以去http://unxutils.sourceforge.net/ 或 http://sourceforge.net/projects/unxutils/下载能运行在你的操作系统上的二进制版本。 less——这也许是我用的最多的。它能够显示文件逐页显示文件内容。你还可以查找文本内容，或者如果你在看一个正在不断更新的日志文件，你可以按下F，然后它会给你显示最新加入的行。 grep——能用正则表达式搜索一组文件。 touch——更新文件的最近修改时间为当前日期/时间，或者如果文件不存在，它会创建一个空文件。 tee——通过tee传送管道命令（例如 someprog | tee logfile）让你复制那个命令的输出到文件，并同时在终端打印输出。 which——如果你在终端运行一个程序foo.exe，你想要知道该程序在什么位置，只需要输入which foo.exe head和tail——这两个让你打印出文件的头N行或后N行 uniq——过滤输出，移除连续的相同行 du——打印一个目录的磁盘使用率（总占用空间） wc——统计文件的行数，单词数和字符数。（当我给编辑写信时我会用它，这样我可以保持我的字数在新闻能允许的最大字数内） cp，rm，mv，ls，cat——这些都有DOS下的等价命令（copy，delete，rename，dir，type），但是这些UNIX的等价命令有时候在脚本里用到，所以我把它们安装到我的path下。 md5sum——在对通过计算文件的MD5哈希码来验证文件完整性时有用 gzip和gunzip——这两个是压缩和解压缩单个文件的。.gz格式较.zip普及程度低一点，但是你偶尔能见到它。 wget和curl——这两个程序可以让你下载网页。 参考：你应该知道的10种软件工具]]></content>
      <categories>
        <category>程序员</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>程序员</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo遇到的坑]]></title>
    <url>%2FBolgBuild%2F2018%2F01%2F03%2FBlogBuild%2FHexo%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Hexo遇到的坑1. imagemin使用npm install hexo-imagemin –save安装imagemin后在根目录 _cofig.yml中配置imagemin如下。 imagemin: enable : true interlaced : false multipass : false optimizationLevel: 2 pngquant : false progressive: false 会有一些图片在 hexo g命令后生成的是0kb，根本打不开，注释掉_cofig.yml中关于imagemin的配置，生成的图片还是0kb，使用npm uninstall hexo-imagemin命令卸载后，就解决了了问题。]]></content>
      <categories>
        <category>BolgBuild</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>BolgBuild</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题如何添"ForkMeOnGithub"]]></title>
    <url>%2FBolgBuild%2F2017%2F12%2F29%2FBlogBuild%2FHexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0ForkMeOnGithub%2F</url>
    <content type="text"><![CDATA[Hexo博客Next主题如何添加”ForkMeOnGithub”如何给网站添加”Fork me on Github”效果？ 1. 效果图展示 2. 实现1. 样式挑选样式可以参考github的文档,可以选择左侧样式还是右侧样式， 2. 修改把官网的的代码拷贝过来添加到Hexo博客根目录/themes/next/layout文件夹下的_layout.swig文件中官网的代码： 123&lt;a target="_blank" href="https://github.com/you"&gt;&lt;img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"&gt;&lt;/a&gt; 比如我的github地址为:https://github.com/Seachal所以代码如下:1234567&lt;body&gt;...&lt;a target="_blank" href="https://github.com/Seachal"&gt;&lt;img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"&gt;&lt;/a&gt;...&lt;/body&gt; 3. 有何问题但是这样会有个问题：手机上的页面也会是这个效果,如果你不想让手机上显示成 那么你需要 修改文件hexo博客根目录\themes\next\layout\_layout.swig 找到如下代码块 1234&lt;html class="&#123;&#123; html_class | lower &#125;&#125;"&gt;&lt;head&gt; &#123;% include '_partials/head.swig' %&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; 添加代码，结果如下: 1234567891011121314151617&lt;head&gt; &#123;% include '_partials/head.swig' %&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &#123;% include '_third-party/analytics/index.swig' %&#125; &lt;style&gt; .forkMeOnGithub&#123; display: none; &#125; @media (min-width: 768px) &#123; .forkMeOnGithub&#123; display: inline; &#125;&#125;&lt;/style&gt;&lt;/head&gt; 最后在2.1节添加的代码块上套上div加上class就行了，代码如下 123&lt;div class="forkMeOnGithub"&gt;&lt;a target="_blank" href="https://github.com/Seachal"&gt;&lt;img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"&gt;&lt;/a&gt;&lt;/div&gt; 这样就只会在桌面版的网页内显示”Fork me on Github”]]></content>
      <categories>
        <category>BolgBuild</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>BolgBuild</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android设置TextView文显示固定字数 省略号表示多余部分]]></title>
    <url>%2FAndroid%2F2017%2F12%2F28%2FAndroid%2FAndroid%E8%AE%BE%E7%BD%AETextView%E6%96%87%E6%98%BE%E7%A4%BA%E5%9B%BA%E5%AE%9A%E5%AD%97%E6%95%B0%20%E7%9C%81%E7%95%A5%E5%8F%B7%E8%A1%A8%E7%A4%BA%E5%A4%9A%E4%BD%99%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[Android设置TextView文显示固定字数 省略号表示多余部分今天在设置TextView文显示固定字数 省略号表示多余部分时，发现android:maxLines和android:ellipsize这两个属性同时使用并没有效果。原因： 把 android:layout_height=&quot;match_parent&quot;改为 android:layout_height=&quot;wrap_content&quot;就有效果了。 ##更多代码在xml中： 123android:ellipsize=&quot;start&quot; 省略号在开头android:ellipsize=&quot;middle&quot; 省略号在中间android:ellipsize=&quot;marquee&quot; 跑马灯 在java文件中： 123tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;START&quot;));tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;MIDDLE&quot;));tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;MARQUEE&quot;));]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TextView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态为TextView控件设置drawableLeft图标,并设置间距]]></title>
    <url>%2FAndroid%2F2017%2F12%2F28%2FAndroid%2F%E5%8A%A8%E6%80%81%E4%B8%BATextView%E6%8E%A7%E4%BB%B6%E8%AE%BE%E7%BD%AEdrawableLeft%E5%9B%BE%E6%A0%87%2C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%97%B4%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[动态为TextView控件设置drawableLeft图标,并设置间距重要属性: textView.setCompoundDrawablePadding(4);//设置图片和text之间的间距 textView.setPadding(-5, 0, 0, 0);//设置整体的padding 代码如下: 12345678910private void addDrwable(TextView textView) &#123; //获取图片 Drawable drawable = ContextCompat.getDrawable(mContext, R.drawable.staff_portrait); drawable.setBounds(0, 0, drawable.getMinimumWidth() / 2, drawable.getMinimumHeight() / 2); //在左侧添加图片 textView.setCompoundDrawables(drawable, null, null, null); //textView.setCompoundDrawablesRelative(drawable, null, null, null); textView.setCompoundDrawablePadding(5);//设置图片和text之间的间距 textView.setPadding(25, 0, 0, 0); &#125; 存在问题TextView的属性Gravity对添加的图片无效，如Gravity的值为center，图片会居左，文字相对于无图片时的位置偏右了一点。所以只能被迫选择列表中的数据全部由居中给为居左]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
        <tag>TextView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo创建文章和草稿]]></title>
    <url>%2FBolgBuild%2F2017%2F12%2F25%2FBlogBuild%2F2018-01-04%2F</url>
    <content type="text"><![CDATA[#首先安装gulp，执行以下命令： 1npm insatll gulp -g 1npm install gulp-htmlclean]]></content>
      <categories>
        <category>BolgBuild</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>BolgBuild</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo创建文章和草稿]]></title>
    <url>%2FBolgBuild%2F2017%2F12%2F25%2FBlogBuild%2FHexo%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0%E5%92%8C%E8%8D%89%E7%A8%BF_2017-12-30-1%2F</url>
    <content type="text"><![CDATA[Hexo创建文章和草稿文章命令行中输入： ======================== $ hexo new “new article” ======================== 之后在source/_posts目录下面，多了一个new-article.md的文件。 打开之后我们会看到： ========================= title: new article date: 2014-11-01 20:10:33 tags: ========================= 文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文。 文章的正文支持markdown格式，建议你先学习一下它的语法。markdown不像html似的一大堆标签，很简单，只有几个符号。 新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。 属性文章可以拥有如下属性： Setting Description Default layout Layout post或page title 文章的标题 date 创建日期 文件的创建日期 updated 修改日期 文件的修改日期 comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字 文件名 动态博客中通过发布文章页面设置的各种属性，在hexo里要这样设置。 分类和标签例如： =========== categories: 日记 tags: Hexo node.js =========== 摘要同wordpress一样，之上的内容为摘要。 layout如果你修改了layout，在scaffolds文件夹里一定要有名字对应的模版文件，否则会采用默认模版。 文件名在配置文件中的new_post_name项可以设置文件名，默认为:title，也就是你在命令行输入的名字。 文件名可以为下面几个变量和字符串常量的任意组合： Variable Description :title Escaped title (lower case and replace spaces with dash) :year Created year (4-digit) :month Created month (2-digit) :i_month Created month (Without leading zeros) :day Created day (2-digit) :i_day Created day (Without leading zeros) 草稿草稿相当于很多博客都有的“私密文章”功能。 ============================ $ hexo new draft “new draft” ============================ 会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。 如果你希望强行预览草稿，更改配置文件： =================== render_drafts: true =================== 或者，如下方式启动server： ====================== $ hexo server –drafts ====================== 下面这条命令可以把草稿变成文章，或者页面： ================================== $ hexo publish [layout] ==================================]]></content>
      <categories>
        <category>BolgBuild</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>BolgBuild</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Mac下配置Github和Bitbucket的SSH]]></title>
    <url>%2FGithub%2F2017%2F12%2F23%2F%E5%A6%82%E4%BD%95%E5%9C%A8Mac%E4%B8%8B%E9%85%8D%E7%BD%AEGithub%E5%92%8CBitbucket%E7%9A%84SSH%2F</url>
    <content type="text"><![CDATA[如何在Mac下配置Github和Bitbucket的SSH第一步：生成 SSH 公钥过程大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 1.查看是否已经有了SSH密钥 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看： 1cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除 12cp -R ~/.ssh ~/.ssh_bakrm -R ~/.ssh 2.生成密钥1ssh-keygen -t rsa -C "你在Github上的邮箱" 第一次要输入file名字，直接回车即可，默认文件名为id_前缀，然后会被要求输入个密码并且确认。 第二步：添加密钥到SSH12cd ~/.sshssh-add -K id_rsa 需要刚才生成密钥时候输入的密码。 在github上添加SSH Key1more id_rsa.pub 查看公钥里的内容并且全部复制下来(包括开头ssh-rsa和结尾邮箱)。 进入到github的setting，找到SSH Keys页面添加一个key，title随意，赋值公钥进去保存即可。 第三步：测试是否成功1ssh git@github.com 成功则返回类似: 12Hi Seachal! You've successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. BitbucketBitbucket.org是一个和Github极其类似的托管库网站，但是他的私有库是免费的，所以一般我们会把私有库放到bitbucket上，而其他库放到github上，毕竟github的SNS属性稍微多些，开源的库就尽量的希望有与其他人的更多互动。给bitbucket添加SSH Key实际上是一样的。测试bitbucket ssh是否可连接 1ssh -T git@bitbucket.org 成功则返回类似: 123logged in as Seachal.You can use git or hg to connect to Bitbucket. Shell access is disabled.]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio快捷键_Mac和Windos和Linux]]></title>
    <url>%2FAndroid%2F2017%2F12%2F23%2FAndroid%2FAndroid%20Studio%E5%BF%AB%E6%8D%B7%E9%94%AE_Mac%E5%92%8CWindos%E5%92%8CLinux%2F</url>
    <content type="text"><![CDATA[Android Studio 为许多常用操作提供了键盘快捷键。 下表按操作系统显示了默认键盘快捷键，包括 Mac 、Windows、Linux 等系统。 说明 Mac Windows/Linux 常规 全部保存 Command + S Control + S 同步 Command + Option + Y Control + S 最大化/最小化编辑器 Control + Command + F12 Control + Shift + F12 添加到收藏夹 Option + Shift + F Alt + Shift + F 使用当前配置文件检查当前文件 Option + Shift + I Alt + Shift + I 快速切换模式 Control + `（反引号） Control + `（反引号） 打开设置对话框 Command + ,（英文逗号） Control + Alt + S 打开项目结构对话框 Command + ;（英文分号） Control + Alt + Shift + S 在标签和工具窗口之间切换 Control + Tab Control + Tab 在 Studio 内导航和搜索 搜索全部内容（包括代码和菜单） 按两次 Shift 按两次 Shift 查找 Command + F Control + F 查找下一个 Command + G F3 查找上一个 Command + Shift + G Shift + F3 替换 Command + R Control + R 查找操作 Command + Shift + A Control + Shift + A 按符号名称搜索 Command + Option + O Control + Alt + Shift + N 查找类 Command + O Control + N 查找文件（而不是类） Command + Shift + O Control + Shift + N 在路径中查找 Command + Shift + F Control + Shift + F 打开文件结构弹出式菜单 Command + F12 Control + F12 在打开的编辑器标签之前导航 Control + 向右/向左箭头 Alt + 向右/向左箭头 跳到源代码 F4 / Command + 向下箭头 F4 / Control + Enter 在新窗口中打开当前编辑器标签 Shift + F4 Shift + F4 最近打开的文件弹出式菜单 Command + E Control + E 最近编辑的文件弹出式菜单 Command + Shift + E Control + Shift + E 转到上一个编辑位置 Command + Shift + 退格键 Control + Shift + 退格键 关闭活动编辑器标签 Command + W Control + F4 从工具窗口返回到编辑器窗口 Esc Esc 隐藏活动或上一个活动工具窗口 Shift + Esc Shift + Esc 转到行 Command + L Control + G 打开类型层次结构 Control + H Control + H 打开方法层次结构 Command + Shift + H Control + Shift + H 打开调用层次结构 Control + Option + H Control + Alt + H 编写代码 生成代码（getter、setter、构造函数、 hashCode/equals、toString、新文件、新类） Command + N Alt + Insert 替换方法 Control + O Control + O 实现方法 Control + I Control + I 控制语句 (if…else / try…catch / etc.) Command + Option + T Control + Alt + T 删除插入符处的行 Command + 退格键 Control + Y 折叠/展开当前代码块 Command + 减号/加号 Control + 减号/加号 折叠/展开所有代码块 Command + Shift + 减号/加号 Control + Shift + 减号/加号 复制当前行或选择 Command + D Control + D 基本代码自动完成 Control + 空格键 Control + 空格键 智能代码自动完成（按预期 类型过滤方法和变量列表） Control + Shift + 空格键 Control + Shift + 空格键 完成语句 Command + Shift + Enter Control + Shift + Enter 快速文档查找 Control + J Control + Q 显示选定方法的参数 Command + P Control + P 转到声明（直接） Command + B 或 Command + 点击 Control + B 或 Control + 点击 转到实现 Command + Alt + B Control + Alt + B 转到超类方法/超类 Command + U Control + U 打开快速定义查找 Command + Y Control + Shift + I 切换项目工具窗口的可见性 Command + 1 Alt + 1 切换书签 F3 F11 通过助记切换书签 Option + F3 Control + F11 通过行注释添加注释/取消注释 Command + / Control + / 通过块注释添加注释/取消注释 Command + Shift + / Control + Shift + / 选择连续增加的代码块 Option + Up Control + W 将当前选择退回到上一个状态 Option + Down Control + Shift + W 移动到代码块起始位置 Option + Command + [ Control + [ 移动到代码块结束位置 Option + Command + ] Control + ] 从当前位置选择到代码块起始位置 Option + Command + Shift + [ Control + Shift + [ 从当前位置选择到代码块结束位置 Option + Command + Shift + ] Control + Shift + ] 从当前位置删除到单词结尾 Option + Delete Control + Delete 从当前位置删除到单词开头 Option + 退格键 Control + 退格键 优化导入 Control + Option + O Control + Alt + O 项目快速修复 （显示意图操作和快速修复） Option + Enter Alt + Enter 重新格式化代码 Command + Option + L Control + Alt + L 自动缩进行 Control + Option + I Control + Alt + I 缩进/取消缩进行 Tab/Shift + Tab Tab/Shift + Tab 智能行合并 Control + Shift + J Control + Shift + J 智能行拆分 Command + Enter Control + Enter 开始新行 Shift + Enter Shift + Enter 下一个/上一个突出显示的错误 F2 / Shift + F2 F2 / Shift + F2 构建并运行 构建 Command + F9 Control + F9 构建并运行 Control + R Shift + F10 调试 调试 Control + D Shift + F9 跳过 F8 F8 逐步执行 F7 F7 智能逐步执行 Shift + F7 Shift + F7 跳出 Shift + F8 Shift + F8 运行到光标位置 Option + F9 Alt + F9 评估表达式 Option + F8 Alt + F8 继续运行程序 Command + Option + R F9 切换断点 Command + F8 Control + F8 查看断点 Command + Shift + F8 Control + Shift + F8 重构 复制 F5 F5 移动 F6 F6 安全删除 Command + Delete Alt + Delete 重命名 Shift + F6 Shift + F6 更改签名 Command + F6 Control + F6 内联 Command + Option + N Control + Alt + N 提取方法 Command + Option + M Control + Alt + M 提取变量 Command + Option + V Control + Alt + V 提取字段 Command + Option + F Control + Alt + F 提取常量 Command + Option + C Control + Alt + C 提取参数 Command + Option + P Control + Alt + P 版本控制/本地历史记录 将项目提交到 VCS Command + K Control + K 从 VCS 更新项目 Command + T Control + T 查看最近变更 Option + Shift + C Alt + Shift + C 打开 VCS 弹出式菜单 Control + V Alt + `（反引号）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Android</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[app目录下的build.gradle详解]]></title>
    <url>%2FAndroid%2F2017%2F07%2F23%2FAndroid%2Fapp%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84build.gradle%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[app目录下的build.gradle详解表示这是一个Android程序模块，如果是作为库，就声明为Library'com.android.library'123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778applyplugin:&apos;com.android.application&apos;android &#123;compileSdkVersion26// 编译版本，指用哪个版本的SDK进行编译buildToolsVersion&quot;26.0.1&quot;//构建工具//对项目的更多细节进行配置defaultConfig &#123;applicationId&quot;com.seachal.myapplicationtestlog&quot;minSdkVersion19targetSdkVersion26versionCode1versionName&quot;1.0&quot;testInstrumentationRunner&quot;android.support.test.runner.AndroidJUnitRunner&quot;&#125;//指定生成安装文件的相关配置buildTypes &#123;//release 闭包用于指定生成正式版安装文件的配置release &#123;minifyEnabledfalse//指定是否对项目的代码进行混淆， true 表示混淆， false 表示不混淆。//proguard-android.txt在默认的SDK目录下，有通用的混淆规则// proguard-rules.pro 有本项目专用的混淆规则proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;),&apos;proguard-rules.pro&apos;&#125;//debug闭包可以忽略不写&#125;&#125;dependencies &#123;//本地依赖声明，它表示将 libs 目录下所有.jar 后缀的文件都添加到项目的构建路径当中compile fileTree(dir:&apos;libs&apos;,include: [&apos;*.jar&apos;])androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123;excludegroup:&apos;com.android.support&apos;,module:&apos;support-annotations&apos;&#125;)// 远程依赖声明compile&apos;com.android.support:appcompat-v7:26.+&apos;//com.android.support.constraint 是域名。constraint-layout是组名，用于区分同一公司的不同库。 1.0.2是版本号compile&apos;com.android.support.constraint:constraint-layout:1.0.2&apos;//compile project(&apos;:helper&apos;) //库依赖声明格式，表示依赖了一个叫helper的Library// 声明测试用例库testCompile&apos;junit:junit:4.12&apos;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>gradle</tag>
        <tag>配置</tag>
        <tag>含义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyCharm与IntelliJ IDEA Python插件FAQ]]></title>
    <url>%2FIDE%2F2017%2F07%2F10%2F2018-01-10-1%2F</url>
    <content type="text"><![CDATA[PyCharm与IntelliJ IDEA Python插件FAQPyCharm与IntelliJ IDEA + Python插件 问：随着PyCharm的宣布，IDEA插件仍然可用？答：是的，我们计划同步发布新的PyCharm构建和插件更新。对于购买了IntelliJ IDEA Ultimate许可证的用户，该插件将保持免费。 问：插件是否支持PyCharm支持的大部分/全部功能？答：IntelliJ IDEA的Python插件是与PyCharm相同的代码库构建的。有些功能可能暂时在插件中不可用，因为与PyCharm相比，最新的IntelliJ IDEA基于早期的IntelliJ平台。 问：PyCharm和Python插件有什么不同？使用PyCharm而不仅仅是插件会有好处吗？答：PyCharm在一些领域提供了一个更简单的用户界面，例如项目管理，IDE设置等。 Python插件依次具有Jython全面的支持功能（跨语言导航，完成和重构）。PyCharm仅支持Jython作为运行应用程序的运行时。 如果你不使用Java / Python集成，PyCharm是一个更好的开始。 问：我可以使用我的IntelliJ IDEA许可证使用PyCharm吗？答：不可以。这两种产品使用不同的许可证制度。如果您想使用这两种产品，则需要购买两个许可证。 问：IntelliJ IDEA和PyCharm之间的项目文件是否兼容？答：在PyCharm中创建的项目可以在安装了Python插件的IntelliJ IDEA中打开，没有任何问题。IntelliJ IDEA允许更灵活的项目配置，例如为项目配置库的可能性。PyCharm将能够打开并使用更高级设置的项目，但是您将无法更改PyCharm中的设置。参考：https://confluence.jetbrains.com/display/PYH/PyCharm+vs.+IntelliJ+IDEA+Python+plugin+FAQ]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IntelliJ</tag>
        <tag>IDE</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[Zhang Seachal，坐标北京，专注 Android 经验分享，性情中人。 写博客的初衷：总结经验，记录自己的成长。]]></content>
  </entry>
  <entry>
    <title><![CDATA[uploads]]></title>
    <url>%2Fuploads%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>

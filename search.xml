<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FVersionControl%2F2018-04-15%2F</url>
    <content type="text"><![CDATA[#在add文件的时候，不小心把add to working copy点击成了下面的ignore。 以至于，自己new的文件，在finder里面能够看到文件，但在cornerstone里就看不到，无法add commit。怎样恢复呢？ 打开右上角图标顺序使左上角两个图标选中， 然后看到点击蓝色图标点击 Revert to last Update 最后保存 最后ignore文件就显示了。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FMac%2F%E6%89%B9%E9%87%8F%E6%96%87%E4%BB%B6%E5%AD%97%E7%AC%A6%E9%9B%86%E8%BD%AC%E6%8D%A2%E4%B8%BAUTF-i%E8%84%9A%E6%9C%AC%EF%BC%88file%20batch%20convert%20char%20set%20%EF%BC%892018-08-19%2F</url>
    <content type="text"><![CDATA[#最近遇到一个大项目，项目使用的encoding 有GBK也有UTF-8， 在intellij中虽然可以一个一个conver，但是感觉太慢了，并且reload为UTF-8也不是长久之计，在Git中仍然是乱码。 查阅了一些资料，写个脚本终于批量把gbk 转换为 utf-8了。这是在mac 10.13中测试的示例。按名称查找文件，转换编码，然后替换原始文件。完美。 新建一个名为 ConvertEncoding.sh文件 将下面的完整代码复制到shell脚本中。 123456789101112#!/bin/bash find ./ -name *.java -type f | \ (while read file; do if [[ "$file" != *.DS_Store* ]]; then if [[ "$file" != *-utf8* ]]; then iconv -f GBK -t UTF-8 "$file" &gt; "$file-utf8"; rm $file; echo mv "$file-utf8" "$file"; mv "$file-utf8" "$file"; fi fi done); ./ 要替换为自己的项目文件夹。 把shell文件拖到terminal中 enter执行。 12345678bogon:~ username$ /Users//Documents/batchconvert.sh -bash: /Users/username/Documents/batchconvert.sh: Permission deniedbogon:~ username$ chmod 777 batchconvert.shchmod: batchconvert.sh: No such file or directorybogon:~ username$ chmod 777 /Users/username/Documents/batchconvert.sh bogon:~ username$ bogon:~ username$ bogon:~ username$ /Users/username/Documents/batchconvert.sh 其中 chmod 777 /Users/username/Documents/batchconvert.sh是给batchconvert.sh赋予全新啊。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FReactNative%2F2018-02-23%2F</url>
    <content type="text"><![CDATA[WebStorm 运行ReactNative配置未发布 1.在最上面找到Run菜单选择当中的Edit 2. 3. 4.]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FBlogBuild%2F2018-02-09%2F</url>
    <content type="text"><![CDATA[#MarkDown注释，隐藏文字1 &lt;!--.bg-blue--&gt; 弗朗茨·李斯特（Franz Liszt，1811年10月22日－1886年7月31日），著名匈牙利作曲家、钢琴家、指挥家，是浪漫主义前期最杰出的代表人物之一。 2 弗朗茨·李斯特（Franz Liszt，1811年10月22日－1886年7月31日），著名匈牙利作曲家、钢琴家、指挥家，是浪漫主义前期最杰出的代表人物之一。 3 弗朗茨·李斯特（Franz Liszt，1811年10月22日－1886年7月31日），著名匈牙利作曲家、钢琴家、指挥家，是浪漫主义前期最杰出的代表人物之一。 《钟》（意大利语：La campanella），或译作《康派涅拉》，是弗朗茨·李斯特创作的《帕格尼尼大练习曲》6首中第3首的钢琴独奏曲。 或者你可以走得更远： 为了提高平台兼容性（并保存一个按键），也可以使用#（这是一个合法的超链接目标），而不是&lt;&gt;： 参考：https://stackoverflow.com/questions/4823468/comments-in-markdown 参考：https://github.com/fan2/Markdown/blob/master/Markdown%20Syntax.md]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FJava%2F2018-06-21%2F</url>
    <content type="text"><![CDATA[# // @Override// @DataSource(“busi”)// @Transactional(readOnly = true, propagation = Propagation.REQUIRED, rollbackFor = Exception.class)// public OperateResult intelligentIdentification(MultipartFile file) {//// UploadActionBean result = new UploadActionBean();// List cigaretteInfoList = new ArrayList&lt;&gt;() ;////// 模式的识别结果数据// JSONArray jsonArray = new JSONArray();// JSONObject jsonObject = new JSONObject();// jsonObject.put(“barCode”, “6901028001687”);// jsonObject.put(“ratio”, “99.5”);// jsonArray.add(jsonObject);// jsonObject = new JSONObject();// jsonObject.put(“barCode”, “6901028081474”);// jsonObject.put(“ratio”, “49.5”);// jsonArray.add(jsonObject);// // 图片识别结果返回一个list的请求结果//// 如果请求成功， 并且，返回的list不为null，size大于0// if (true) {// cigaretteInfoList = cigaretteInfoMapper.getCigaretteList(jsonArray);//// 从数据库中查出的数据对象，// for (int i = 0; cigaretteInfoList != null &amp;&amp; i &lt; cigaretteInfoList.size(); i++) {//// for (int j = 0; j &lt; jsonArray.size(); j++) {// if (cigaretteInfoList.get(i).getBarBoxBarCode().equals(jsonArray.getJSONObject(j).getString(“barCode”))){//// cigaretteInfoList.get(i).setRatio(jsonArray.getJSONObject(j).getString(“ratio”));// }// }// }// }// return OperateResultCode.SUCCESS.getResult().setDataList(cigaretteInfoList);// } @Override @DataSource(&quot;busi&quot;) @Transactional(readOnly = true, propagation = Propagation.REQUIRED, rollbackFor = Exception.class) public OperateResult intelligentIdentification(MultipartFile file) { // UploadActionBean result = new UploadActionBean(); List cigaretteInfoList = new ArrayList&lt;&gt;() ; // 模式的识别结果数据 JSONArray jsonArray = new JSONArray(); JSONObject jsonObject = new JSONObject(); jsonObject.put(“barCode”, “6901028001687”); jsonObject.put(“ratio”, “99.5”); jsonArray.add(jsonObject); jsonObject = new JSONObject(); jsonObject.put(“barCode”, “6901028081474”); jsonObject.put(“ratio”, “49.5”); jsonArray.add(jsonObject); // 图片识别结果返回一个list的请求结果// 如果请求成功， 并且，返回的list不为null，size大于0 if (true) {// 从数据库中查出的数据对象， cigaretteInfoList = cigaretteInfoMapper.getCigaretteList(jsonArray); Map&lt;String, CigaretteInfo&gt; mapCigarette = new HashMap&lt;String, CigaretteInfo&gt;(); for (CigaretteInfo cigaretteInfo : cigaretteInfoList) { mapCigarette.put(cigaretteInfo.getBarBoxBarCode(), cigaretteInfo); } for (int j = 0; j &lt; jsonArray.size(); j++) { if (mapCigarette.get(jsonArray.getJSONObject(j).getString(&quot;barCode&quot;)).getBarBoxBarCode().equals(jsonArray.getJSONObject(j).getString(&quot;barCode&quot;))){ mapCigarette.get(jsonArray.getJSONObject(j).getString(&quot;barCode&quot;)).setRatio(jsonArray.getJSONObject(j).getString(&quot;ratio&quot;)); } } } return OperateResultCode.SUCCESS.getResult().setDataList(cigaretteInfoList); }]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FJava%2F2018-03-12%2F</url>
    <content type="text"><![CDATA[# 1there is no default constructor available in BaseAdapter父类中没有可用的默认构造函数。这种情况下就需要显示的调用父类的构造方法， 毕竟有父类才有子类，通过父类的构造方法才能构造子类。因为 1234public BrandCountryRegionAdapter(Context context, int layoutId, List&lt;ReportProductArea&gt; datas) &#123; super(); int i = 1； &#125; 和 123public BrandCountryRegionAdapter(Context context, int layoutId, List&lt;ReportProductArea&gt; datas) &#123; int i = 1； &#125; 的内容是一样的，第二种写法是第一种的简写。 修正写法 1234public BrandCountryRegionAdapter(Context context, int layoutId, List&lt;ReportProductArea&gt; datas) &#123;+ super(context, layoutId, datas); int i = 1； &#125; 参考:http://blog.csdn.net/ozuijiaoweiyang/article/details/50477898 2attempting to use incompatible return type.尝试使用不兼容的返回类型。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FBlogBuild%2F%E5%B8%B8%E7%94%A8%E5%8D%9A%E5%AE%A2Metaweblog%20Api%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[常用博客Metaweblog Api地址 CSDN： http://write.blog.csdn.net/xmlrpc/index 博客园（cnblogs)：http://www.cnblogs.com/Blog名(你的用户名)/services/metaweblog.aspx。其中 Blog 名 请换为您的博客名。cnblogs 的博客后台设置，拉到最下面，也可以找到这个网址。比如说我的是 http://rpc.cnblogs.com/metaweblog/Seachal 两者网址不同，但是效果一样。 开源中国（oschina)：https://my.oschina.net/action/xmlrpc 51cto：http://imguowei.blog.51cto.com/xmlrpc.php 网易（163）：http://os.blog.163.com/word/ typecho 博客：http://xx.com/action/xmlrpc，其中 xx.com 为你的博客网址。如果 typecho 还没有进行 url rewrite，则为 http://xx.com/index.php/action/xmlrpc 新浪博客： http://upload.move.blog.sina.com.cn/blog_rebuild/blog/xmlrpc.php 新浪博客的 API 已关闭了]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FAndroid%2FLibrary%2F%E5%9B%BE%E8%A1%A8%E5%BC%80%E6%BA%90%E5%BA%93MPAndroidChart%2F</url>
    <content type="text"><![CDATA[图表开源库MPAndroidChart的使用 使用版本3.0.3 chart 的一些使用规则 一个 linechart 需要两个ArrayList，其他chart 也类似。 ArrayList xList, ArrayList yList; xList he yList的size相等。 （i,x）与 （i,y）基于i相交于一点才会绘制在 view中。 1.lineChart 1.1 123456789// 关于图表的描述 int textColor = ContextCompat.getColor(mActivity, R.color.stage_text); Description description = new Description(); description.setText("周"); description.setTextColor(textColor); description.setTextSize(12); description.setXOffset(5); description.setYOffset(-15);// 相对于Y位置偏移量 mChart.setDescription(description); //图表默认右下方的描述， 1.2 12345678910//图例设置 图例（声明颜色line， 颜色bar代表什么数据， 如红色代表订购率 ）Legend legend = mChart.getLegend();legend.setHorizontalAlignment(Legend.LegendHorizontalAlignment.RIGHT);//设置图例水平对齐, 居右侧legend.setVerticalAlignment(Legend.LegendVerticalAlignment.TOP);// 居上侧legend.setOrientation(Legend.LegendOrientation.HORIZONTAL);// 水平legend.setDrawInside(true); //legend.setDirection(Legend.LegendDirection.LEFT_TO_RIGHT);// 颜色在左 文字在右legend.setForm(Legend.LegendForm.LINE);////设置图例形状， SQUARE(方格) CIRCLE（圆形） LINE（线性）legend.setTextSize(12f);legend.setEnabled(true); 1.3 y轴 123456789101112//y轴设置 左侧 YAxis leftAxis = mChart.getAxisLeft(); leftAxis.setPosition(YAxis.YAxisLabelPosition.OUTSIDE_CHART);//设置y-labels显示的位置 leftAxis.setDrawGridLines(true);//绘制y网格线 leftAxis.enableGridDashedLine(4f, 2f, 0f);//启用网格虚线 leftAxis.setTextColor(barColor);//label字体颜色 leftAxis.setTextSize(11);//label字体大小 leftAxis.setLabelCount(Y_LABEL_COUNT, false);//y label显示的数量 leftAxis.setDrawLabels(true);//折线上显示值，则不显示坐标轴上的值 leftAxis.setAxisMinimum(0f); IAxisValueFormatter leftFormaterr = new MyLeftYAxisValueFormatter(); leftAxis.setValueFormatter(leftFormaterr); IAxisValueFormatter 格式话坐标的显示方式例如给y轴的所有刻度值后面都加上 ”条“、”%“ 1.4 绘制line或者bar等等 12345678910111213141516171819202122ArrayList&lt;ILineDataSet&gt; dataSets = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; entriesList.size(); ++i) &#123; LineDataSet set = new LineDataSet(entriesList.get(i), titles[i]); if (lineColors != null) &#123; set.setColor(lineColors[i]); set.setCircleColor(lineColors[i]); set.setCircleColorHole(Color.WHITE); &#125; else &#123; set.setColor(LINE_COLORS[i % 3]); set.setCircleColor(LINE_COLORS[i % 3]); set.setCircleColorHole(Color.WHITE); &#125; set.setCircleRadius(2.0f);//折线上圆点的大小。 set.setMode(LineDataSet.Mode.HORIZONTAL_BEZIER);//设置折线图样式 圆滑曲线 平滑曲线 或者 折线 set.setLineWidth(1.5f);//线的宽度（线的粗度） set.setDrawCircles(true);//禁止显示数据坐标圆点 //设置显示/不显示 在坐标点上方显示坐标值。 set.setDrawValues(false); //Enables / disables drawing values (value-text) for all DataSets this data object contains. set.setAxisDependency(YAxis.AxisDependency.RIGHT);// 数值属于右侧Y轴 setRightAxisMaximum(deliveryLevelTrend); dataSets.add(set); &#125; 2.barChart3.CombinedChart3.112345678910111213CombinedData data = new CombinedData(); data.setData(generateLineData()); data.setData(generateBarData()); data.setData(generateBubbleData()); data.setData(generateScatterData()); data.setData(generateCandleData()); data.setValueTypeface(mTfLight); xAxis.setAxisMaximum(data.getXMax() + 0.25f); mChart.setData(data); mChart.invalidate(); 所有数据都必须set到一个 CombinedData中去，不然是会报错的。也很好立即， CombinedChart就是把所有的图表整合为一个。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FAndroid%2FLibrary%2FpictureSelector%2F</url>
    <content type="text"><![CDATA[# pictureSelector 选择图片的开源库测试从A页面到 选择图片页面（B），点击B上的按钮后B 回到到A的过程中， B大约需要1S的时间关闭的原因是什么。A 通过 StartActivityforresult 启动， B关闭后回到A.A页面使用了 BGA-zxing B ok1 1527488490790 ok2 1527488490790 ok3 1527488490811 Bactivity关闭 会返回到A Activity。 A onCreate1527488485885 onStart 1527488485887 onResume 1527488486233 onStop1527488488353 onStart 1527488490846 B关闭返回到A 可以看到B 关闭回到A耗时非常短（ok2 和本onstart的差值 ），其实 onResume 1527488491218 onStop 1527488494359 onDestroy1527488494359 A2是一个简单页面 B Activity ok1 1527489826242 ok2 1527489826242 ok3 1527489826278 A2 Activity onCreate 1527489817153 onStart1527489817156 onResume1527489817157 onStop1527489820219 onStart 1527489826319 onResume 1527489826319 onStop1527489886202 得出结论， 相较于A2，A页面使用了Zxing，zxing比较耗时。所以，耗时发生在 A页面再次 onResume， BGAQRCode 中，onStart到onResume速度特别快。BGAQRCode使用的事自己图片选择。onCreate1527492375031onStart1527492375434onResume1527492375434 onStop 1527492380028onStart 1527492381807onResume 1527492381807]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FAndroid%2FLibrary%2F2018-05-28%2F</url>
    <content type="text"><![CDATA[Android开发在onResume中执行耗时操作导致从其他界面返回特别慢 以pictureSelector 为基础，做的验证试验。 今天改别人的一个bug时遇见一个问题，发现某个界面点击返回以后特别慢，得等一会儿才能返回到上一个界面。 当时第一反应可能是在点击返回的时候或者是在Activity的onDestroy里面做了很多耗时的操作导致点击返回的时候出现特别慢的问题，但是仔细查看了一下代码发现在返回按钮的监听或者是设备返回键的监听都没有做什么操作，onDestroy里同样没做什么操作，这就奇怪了问题到底出在哪里呢？ 经过一番查找调试分析，觉得问题可能不是出在当前界面，将视线转到要返回的上一个界面，发现重写了onResume方法，可能是这个方法执行了耗时的操作导致的，打印了一下这个方法的耗时时间发现耗时也不是很高啊还不到10ms，难道问题的关键不是在这里？ 为了验证我的想法我自己写了个demo，在AActivity的onResume里执行Thread.sleep(10000)睡眠10秒，跳转到BActivity然后点击返回。果然，当点击返回的时候会B会停5秒左右关闭，然后黑屏5秒左右才会回到AActivity。代码如下 1234567891011@Override protected void onResume() &#123; try &#123; Thread.sleep(10000); Log.i(TAG, "Resume1000"+System.currentTimeMillis()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; super.onResume(); Log.i(TAG, "onResume"+System.currentTimeMillis()); &#125; 通过demo说明问题很有可能是出在onResume里面，再仔细看了看onResume里的代码，发现在onResume里执行了handler.sendMessage发送消息，会不会是在handler里面执行的代码耗时里，调试一下发现果然是这里面的代码出现了耗时的操作。 找到问题所在了就好办了，将这段耗时的操作提取到线程里执行，执行完后再使用handler通知UI刷新界面，ok重新运行程序，测试一下，点击返回很流畅，搞定。 记录一下免得自己以后也在开发中犯同样的错误。 思考页面优化 页面速度 写这个例子是，遇到的自己掌握不牢固的问题。 1.Thread 1.1 错误的演示代码： 123456789101112131415161718192021222324@Override protected void onResume() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; resume(); Log.i(TAG, "Resume3000"+System.currentTimeMillis()); &#125; &#125;).start(); Log.i(TAG, "onResume"+System.currentTimeMillis()); &#125; private void resume()&#123; super.onResume(); &#125; 1.2 代码 123456789101112131415161718192021@Overrideprotected void onResume() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; // TODO Auto-generated method stub try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; Log.i(TAG, "Resume3000"+System.currentTimeMillis()); &#125; &#125;).start(); super.onResume(); Log.i(TAG, "onResume"+System.currentTimeMillis());&#125; 结果： 12I/SimpleViewActivity: onResume1527517858625I/SimpleViewActivity: Resume30001527517861619 结论： new Thread 创建了新的线程， （是异步的了？），所以，线程内的代码执行的比线程代码下面的代码晚。 http://itindex.net/detail/54784-android-%E7%BA%BF%E7%A8%8B-%E5%A4%A7%E5%9D%91]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FAndroid%2FLibrary%2FBGAQRCode%2F</url>
    <content type="text"><![CDATA[# QRCodeView 是抽象类， 这样ZxingView，ZbarView就可以更好的根据自己的特性进行拓展， ScanBoxView 是真正的扫描框 12345678910111213141516171819202122232425262728293031&lt;cn.bingoogolapple.qrcode.zxing.ZXingView android:id="@+id/zxingview" style="@style/MatchMatch" app:qrcv_animTime="1000" app:qrcv_barCodeTipText="将条码放入框内，即可自动扫描" app:qrcv_barcodeRectHeight="120dp" app:qrcv_borderColor="@android:color/white" app:qrcv_borderSize="1dp" app:qrcv_cornerColor="@color/colorPrimaryDark" app:qrcv_cornerLength="20dp" app:qrcv_cornerSize="3dp" app:qrcv_customScanLineDrawable="@drawable/scan_icon_scanline" app:qrcv_isBarcode="false" app:qrcv_isCenterVertical="false" app:qrcv_isOnlyDecodeScanBoxArea="false" app:qrcv_isScanLineReverse="true" app:qrcv_isShowDefaultGridScanLineDrawable="false" app:qrcv_isShowDefaultScanLineDrawable="true" app:qrcv_isShowTipBackground="true" app:qrcv_isShowTipTextAsSingleLine="false" app:qrcv_isTipTextBelowRect="false" app:qrcv_maskColor="#33FFFFFF" app:qrcv_qrCodeTipText="将二维码/条码放入框内，即可自动扫描" app:qrcv_rectWidth="200dp" app:qrcv_scanLineColor="@color/colorPrimaryDark" app:qrcv_scanLineMargin="0dp" app:qrcv_scanLineSize="0.5dp" app:qrcv_tipTextColor="@android:color/white" app:qrcv_tipTextSize="12sp" app:qrcv_toolbarHeight="56dp" app:qrcv_topOffset="20dp"/&gt; 在xml中的很多参数是借ZXingView（QRCodeView）传给了ScanBoxView。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FAndroid%2F2018-04-18-%E9%9A%90%E8%97%8F%E6%A0%87%E9%A2%98%E6%A0%8F%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[隐藏标题栏的问题：继承了AppCompatActivity的Activity无法通过调用requestWindowFeature(Window.FEATURE_NO_TITLE)来隐藏标题栏。 12345678public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); //无效 setContentView(R.layout.activity_main); &#125;&#125; 既然这条路走不通，我就在AndroidManifest.xml将主题改为@android:style/Theme.NoTitleBar 12345&lt;application android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:theme="@android:style/Theme.NoTitleBar"//运行出错&gt; 在Android Monitor中看到错误报告：You need to use a Theme.AppCompat theme (or descendant) with this activity.（你必须使用Theme.AppCompat主题或者其子类主题） 解决方法：在AndroidManifest.xml中将主题更改为Theme.AppCompat.Light.NoActionBar、Theme.AppCompat.NoActionBar或Theme.AppCompat.DayNight.NoActionBar中的一个，即可隐藏标题栏 12345&lt;application android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:theme="@style/Theme.AppCompat.Light.NoActionBar"//成功隐藏标题栏&gt; 在activity中设置也可以 123456&lt;activity android:name=".CameraActivity" android:theme="@style/Theme.AppCompat.Light.NoActionBar" android:configChanges="orientation|screenLayout|keyboardHidden" android:hardwareAccelerated="true" android:screenOrientation="portrait"&gt; 或者直接修改style.xml文件 1234567891011121314&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name="colorPrimary"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name="colorPrimaryDark"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name="colorAccent"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; &lt;style name="Theme.MainActivity" parent="AppTheme"/&gt; &lt;style name="Theme.PreviewActivity" parent="Theme.AppCompat.NoActionBar"/&gt;&lt;/resources&gt; 123&lt;activity android:name=".PicturePreviewActivity" /&gt;]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FAndroid%2F2018-03-21%2F</url>
    <content type="text"><![CDATA[android studio修改项目名(project name)在使用Android studio 开发，想要修改我们的工程名或者包名，却感到无从下手该怎么办呢？ 一般修改工程名都会： 选中工程右键 &gt; refactor &gt; rename 填好名字确定后被提示 ”can’t rename root module” 因为Android Studio只能修改根目录内的所有文件。 修改Project工程名解决办法: 1.首先关闭Android studio，然后找到工程所在的文件夹，把工程文件夹重命名为想要的名字。如图： 2.用Android studio重新打开android_service这个工程。如图：改为 以下演示的都是，修改后的， 3.修改 .iml文件名为terminal-android-guizhou.iml 和这个文件里面的 1&lt;module external.linked.project.id="terminal-android-guizhou" 如图： 4 导入到Android Studio 5.目录.idea/modules.xml里面的fileurl导入工程时已经自动改正，可以查看一下。如图： 6．Run一下工程Ok了！ 修改Package包名解决办法:在 Project工具栏点击这里 出现下图将Compact Empty Middle前面的勾去掉，包的层级将会改变。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FAndroid%2F2018-04-18-1_Unable%20to%20merge%20dex%2F</url>
    <content type="text"><![CDATA[“Unable to merge dex”问题解决今天在引用一个库UCrop时，报错： 123456Error:Execution failed for task ':cameraphotoframe:transformDexArchiveWithExternalLibsDexMergerForDebug'.&gt; java.lang.RuntimeException: com.android.builder.dexing.DexArchiveMergerException: Unable to merge dex翻译器：错误：执行失败的任务'：应用程序：转换Dex存档与外部库Dex合并调试'。&gt; java.lang.Runtime异常：java.lang.Runtime异常：com.android.builder.dexing.Dex归档合并异常：无法合并dex 原因是引入了重复的lib导致的：开始翻这个库的源码： 1234dependencies &#123; implementation 'com.android.support:appcompat-v7:27.1.0' implementation 'com.squareup.okhttp3:okhttp:3.8.1'&#125; 我的module 12compile 'com.github.yalantis:ucrop:2.2.2' implementation 'com.android.support:appcompat-v7:26.1.0' 然后删掉自己的的appcompat，重新编译，成功了！ 当你遇到这样的错误时，一定要先检查你的build.gradle是不是有重复的包 参考：https://stackoverflow.com/questions/46267621/unable-to-merge-dex?page=1&amp;tab=votes#tab-top 第二种情况All com. Android. Support libraries must use the exact same version specification (mixing versions can lead to runtime crashes). Found versions 27.1.0, 26.1.0. Examples include com. Android. Support: animated-vector-drawable:27.1.0 and com. Android. Support: design:26.1.0 more… (8 F1) This support library should not use a different version (27) than the compileSdkVersion (26) more.. (8 F1) compileSdkVersion 与com.android.support:design:$supportLibVersion” 的版本不一致。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Funcategorized%2F2018%2F10%2F21%2FAndroid%2F2018-02-28%2F</url>
    <content type="text"><![CDATA[Android Profiler分为三大模块： cpu、内存 、网络。基本的使用在上一篇文章有讲到。这里详细说一下。一、 CPU分析器CPU ProfilerCPU分析器可帮助您实时检查应用程序的CPU使用情况和线程活动，并记录方法跟踪，以便您可以优化和调试应用程序的代码。 要打开CPU Profiler，请按照下列步骤操作： 点击 View &gt; Tool Windows &gt; Android Profiler (还可以点击工具栏的). 从Android Profiler工具栏中选择要配置的设备和应用程序进程(如果您已通过USB连接设备但未看到它，请确保已启用USB调试) 单击CPU时间轴中的任意位置打开CPU Profiler。 1.1 为什么要优化CPU的使用优化CPU使用率有许多优点，例如提供更快更流畅的用户体验，并保持设备电池寿命。它还可以帮助您的应用程序在各种较新旧的设备上运行良好，您可以使用CPU分析器在与应用程序交互时监视CPU使用情况和线程活动，但是，有关应用程序执行代码的更详细信息，应记录并检查方法跟踪。 对于应用程序进程中的每个线程，您可以找到在一段时间内执行哪些方法以及每个方法在执行期间消耗的CPU资源。您还可以使用方法跟踪来识别调用者和被调用者，调用者是一种调用另一种方法的方法，被调用方是另一种方法调用的方法。您可以使用此信息来确定哪些方法太频繁地调用特定资源繁重的任务，就可以尝试优化应用程序的代码以避免不必要的工作。 如果要收集详细的系统级数据，帮助您检查本地系统进程并解决由丢帧引起的UI jank，则应使用Systrace。或者，如果要导出使用Debug捕获的.trace文件，则应使用Traceview 1.2 CPU Profiler概述当您打开CPU分析器时，它会立即开始显示应用程序的CPU使用情况和线程活动。你会看到类似于下图的内容 如上图所示，CPU Profiler的默认视图包括以下内容： ①Event timeline： 显示您的应用程序在其生命周期中转换不同状态的活动，并指示用户与设备的交互，包括屏幕旋转事件。要了解有关事件时间轴的更多信息，包括如何启用它，请阅读我上一篇文章说到的启用高级分析 ②CPU timeline: 显示您的应用程序的实时CPU使用率（占总可用CPU的百分比）以及应用程序使用的线程总数，时间轴还显示其他进程的CPU使用情况（如系统进程或其他应用程序），所以您可以将其与应用程序的使用情况进行比较。您可以通过沿着时间轴的水平轴移动鼠标来检查历史CPU使用率数据。 ③Thread activity timeline: 列出属于您的应用程序进程的每个线程，并使用不同的颜色在时间轴上指示其活动。记录方法跟踪后，可以从此时间轴中选择一个线程，在跟踪窗格中检查其数据。 绿色: 线程处于活动状态或准备好使用CPU。也就是说，它处于”运行”或”可运行”状态。 黄色： 线程处于活动状态，但是在完成其工作之前，它正在等待I / O操作（如文件或网络I / O）。 灰色： 线程正在睡眠，不会消耗任何CPU时间，当线程需要访问尚未可用的资源时，有时会发生这种情况。要么线程进入自愿性睡眠，要么内核使线程休眠，直到所需的资源可用。 ④Tracing type：允许您选择以下选项之一来确定分析器如何记录方法跟踪。 Sampled： 在应用程序执行期间，您可以频繁地捕获应用程序的调用堆栈。profiler将捕获的数据集进行比较，以获取关于应用程序代码执行的时间和资源使用信息。基于sampled跟踪的一个固有问题是，如果您的应用程序在捕获调用堆栈并在下一次捕获之前退出该方法，那么该方法调用不会被分析器记录。如果您对具有这样短生命周期的跟踪方法感兴趣，您应该使用工具跟踪。 Instrumented： 在您的应用程序运行时记录每个方法调用的开始和结束时的时间戳。收集时间戳并与生成方法跟踪数据进行比较，包括时间信息和CPU使用。请注意，对每种方法进行检测的开销会影响运行时性能，并可能影响性能分析，因此对于具有相对较短的生命周期的方法来说，这更加值得注意。此外，如果您的应用程序在短时间内执行大量的方法，profiler可能很快超过它的文件大小限制，进而不能记录任何进一步的跟踪数据。 ⑤Record button：开始和停止记录方法跟踪。要了解更多信息，请继续看下去 提示：profiler还报告了Android Studio和Android平台在你的应用程序过程中添加的线程的CPU使用情况，如JDWP、Profile Saver、Studio:VMStats、Studio:Perfa和Studio:Heartbeat(尽管，在线程活动时间线中显示的确切名称可能会有所不同)。这意味着您的应用程序在CPU时间轴上的CPU使用率也会报告这些线程使用的CPU时间。您可以在线程活动时间表中看到这些线程，并监视它们的活动。(但是，由于profiler线程执行native代码，因此无法为它们记录方法跟踪数据。)Android Studio会报告这些数据，这样你就可以很容易地识别出线程活动和CPU使用实际上是由你的应用程序代码引起的。 1.3 记录和检查方法跟踪要开始记录方法跟踪，从下拉菜单中选择Sampled或Instrumented类型，然后单击Record开始进行记录，完成后点击Stop recording停止记录。profiler自动选择记录的时间帧，并在方法跟踪窗格中显示它的跟踪信息，如下图所示。如果要检查不同线程的方法跟踪，只需从线程活动时间轴中选择它。 ① Selected time frame: 在跟踪窗格中检查的记录时间框架的部分。当您第一次记录一个方法跟踪时，CPU分析器将自动选择您在CPU时间线中记录的整个长度。如果要检查仅记录的时间帧的一部分的方法跟踪数据，您可以单击并拖动高亮显示区域的边缘来修改它的长度。 ②Timestamp： 表示记录方法跟踪的开始和结束时间(相对于profiler开始从设备收集CPU使用信息时)。你可以点击时间戳来自动选择整个记录作为你选定的时间框架——如果你有多个你想要转换的记录，这是非常有用的。 ③Trace pane：显示您所选择的时间框架和线程的方法跟踪数据。仅当您记录至少一个方法跟踪后，此窗格才会显示。在此窗格中，您可以选择如何查看每个堆栈跟踪（使用跟踪选项卡）以及如何测量执行时间（使用时间参考下拉菜单）。 ④: 选择显示为Top Down tree, Bottom Up tree, Call Chart, or Flame Chart这些类型的图。您可以在下面的部分中了解有关每个跟踪窗格选项卡的更多信息。 从下拉菜单中选择以下选项之一，以确定如何测量每个方法调用的时序信息： Wall clock time： 表示实际经过时间。 Thread time：计时信息表示实际的消耗时间减去不消耗CPU资源的那段时间的任何部分。对于任何给定的方法，它的线程时间总是小于或等于它的时钟时间。使用线程时间让您更好地了解给定方法所消耗的线程实际CPU使用量 1.3.1 使用Call Chart选项卡检查跟踪Call Chart选项卡提供一个方法跟踪的图形表示，其中一个方法调用(或调用者)的周期和时间在水平轴上表示，而它的callees则显示在垂直轴上。对系统api的方法调用以橙色显示，调用您的应用程序自己的方法以绿色显示，方法调用第三方api(包括java语言api)以蓝色显示。下面的图显示了一个示例调用图，并说明了给定方法的自时间、子时间和总时间的概念。关于如何使用自上而下和自下而上检查痕迹的部分，请继续看下去 提示： 如果想要跳转到方法的源代码，请右键单击该方法，然后选择Jump to Source。这可以从任何窗格选项卡工作。 1.3.2 使用火焰图表(Flame Chart)选项卡检查痕迹火焰图选项卡提供了一个反向调用图表，聚合了相同的调用堆栈。也就是说，收集相同的调用序列的相同方法被收集并表示为火焰图中的一个较长的栏(而不是将它们显示为多个更短的条，如调用图所示)。这样就更容易看出哪些方法消耗的时间最多。然而，这也意味着横轴不再表示时间轴，相反，它表示每个方法执行的相对时间。 为了帮助说明这个概念，考虑下面图4中的调用图表。注意，方法D对B(B1、B2和B3)进行多次调用，其中一些调用B对C(C1和C3)进行调用。 因为B1、B2和B3共享相同的序列调用者(A→D→B)聚合,如下所示。同样,C1和C3聚合,因为它们共享相同的序列调用者(A→D→B→C)注意不包括C2,因为它有不同的调用者序列(A→D→C)。 聚合方法调用用于创建flame 图，如下图所示。注意，对于任何给定的方法调用，在flame图中，消耗最多CPU时间的callees首先出现。 1.3.3 使用自上而下和自下而上检查Top Down选项卡显示方法调用的列表，扩展方法节点显示其callees。下图显示了上面的图3中调用图的顶部向下图。图中的每个箭头都是从调用者到callee。 下图所示，在顶部的down选项卡中扩展方法A的节点将显示它的callees、方法B和D。在此之后，扩展方法D的节点将暴露它的callees、方法B和C，等等。与火焰图选项卡类似，顶部向下的树聚合跟踪信息，用于共享相同调用堆栈的相同方法。也就是说，火焰图标签提供了顶部下标签的图形表示。 Top Down选项卡提供以下信息，以帮助描述在每个方法调用上花费的CPU时间(在选定的时间段内，时间也代表线程总时间的百分比): Self:方法调用用于执行自己的代码而不是它的callees的时间量，如上面的图3所示。 Children：方法调用花费的时间用于执行其被调用者，而不是其自己的代码，如图3中的方法D所示。 Total：方法的Self和Children的时间的总和。这表示应用程序执行方法调用的总时间量，如图3所示的方法D。 Bottom Up选项卡显示一个方法调用列表，扩展方法的节点显示其调用者。使用上图所示的例子中,下图提供了一个自下而上方法C .在自下而上的树中打开方法C的节点，显示每个独特的调用者,方法B和d .注意,虽然B两次调用C,B当扩大节点只出现一次自下而上方法C的树。再此之后，展开节点B显示其调用者方法A和D. Bottom Up选项卡对于那些消耗最多(或最少)CPU时间的方法的排序方法很有用。您可以检查每个节点，以确定哪些调用者在调用这些方法上花费最多的CPU时间。与上面的树相比，底部树中每个方法的定时信息都是在每棵树的顶部(顶部节点)的方法。在记录期间，CPU时间也被表示为线程总时间的百分比。下表有助于解释如何解释顶级节点及其调用方方法(子节点)的定时信息。 名称 Self Children Total 自下而上树顶部的方法（顶层节点） 表示用于执行其自己的代码而不是其callees的方法的总时间。与上面的树相比，这个时间信息表示在记录期间对该方法的所有调用的总和。 表示用于执行callees而不是自己的代码的总时间。与上面的树相比，这个时间信息表示在记录期间对该方法的callees调用的所有调用的总和。 Self时间和Children的时间总和 Caller 方法 (子节点) 表示调用者调用callee的总时间。使用上图中的底向上树作为例子，方法B的自我时间将等于每个方法C调用时的Self时间的总和。 表示调用者调用的callee的总子时间。在上图中使用底部向上的树为例，方法B的孩子时间将等于每个方法C调用时执行方法C的总和。 Self时间和Children的时间总和 对于给定的记录，当profiler达到文件大小限制时，Android Studio停止收集新数据(但是这并没有停止记录)。这种情况在执行检测跟踪时通常会发生得更快，因为这种类型的跟踪会在较短的时间内收集更多的数据，而不是取样跟踪。如果将检查时间帧扩展到在到达限制后发生的记录期间，那么跟踪窗格中的计时数据不会发生变化(因为没有可用的新数据)。此外，当您只选择没有可用数据的记录的部分时，跟踪窗格将显示NaN用于计时信息。 二、 内存分析器memory profiler内存分析器是Android Profiler中的一个组件，它可以帮助您识别内存泄漏和内存溢出，从而导致存根、冻结甚至应用程序崩溃。它显示了应用程序内存使用的实时图，让您捕获堆转储、强制垃圾收集和跟踪内存分配。 要打开内存分析器和cpu检查器一样，就在隔壁。 2.1 为什么使用内存分析器Android提供了一个托管内存环境——当它确定你的应用不再使用某些对象时，垃圾收集器会将未使用的内存释放回堆。在所有Android版本的某个点上，系统必须短暂地暂停代码。大多数时候，停顿是不可察觉的。但是，如果你的应用程序分配内存的速度快于系统收集的速度，你的应用程序可能会被延迟，而收集器释放了足够的内存来满足你的分配。延迟可能会导致应用程序跳过帧并导致明显的慢速。 即使你的应用程序没有表现出缓慢，如果它泄露了内存，它仍然可以保留那个内存，即使它在后台。通过强制不必要的垃圾收集事件，这种行为可以降低系统内存性能的其他部分。最终，系统不得不杀死你的应用程序来回收内存。然后当用户返回到你的应用程序时，它必须重新启动。 为了帮助防止这些问题，您应该使用内存分析器来执行以下操作： 在可能导致性能问题的时间轴中寻找不良的内存分配模式 Dump Java堆，以便在任何时间查看哪些对象正在使用内存。长时间的堆转储可以帮助识别内存泄漏。 在正常和极端的用户交互过程中记录内存分配，以精确地确定您的代码在短时间内分配的对象或分配被泄漏的对象。 有关可以减少应用程序内存使用的编程实践的信息，请参阅管理应用程序的内存。 2.2 内存分析器概述 如上图所示，内存分析器的默认视图包括以下内容： ① 强制执行垃圾收集事件的按钮。 ② 捕获堆转储的按钮。 ③ 记录内存分配的按钮。 ④ 放大时间线的按钮。 ⑤ 跳转到实时内存数据的按钮。 ⑥ 事件时间线显示活动状态、用户输入事件和屏幕旋转事件。 ⑦ 内存使用时间表，其中包括以下内容： 每个内存类别使用多少内存的堆栈图，如左边的y轴和顶部的颜色键所示。 虚线表示已分配对象的数量，如右侧y轴所示。 每个垃圾收集事件的图标。 但是，默认情况下并不是所有的分析数据都可见。如果您看到一条消息，说“高级分析不可用于所选进程”，则需要启用高级分析以查看以下内容： 活动时间表 分配对象的数量 垃圾收集事件 提示： 与之前的Android监控工具相比，新的内存分析器记录了你的内存使用情况，所以看起来你的内存使用量会更高。内存分析器监视一些额外的类别，这些类别增加了总数，但如果您只关心Java堆内存，那么“Java”的数字应该与上一个Android监视器的值类似。新的号码记录了从Zygote分派到应用程序的Java堆中的所有物理内存页面，这准确表示您的应用程序实际使用多少物理内存。 2.3 记录内存分配查看堆转储时，查看分配了多少内存的快照很有用，它不会显示如何分配内存。为此，您需要记录内存分配。完成记录会话后，您可以看到以下记录的持续时间： 分配了哪些对象以及它们使用了多少空间。 在堆栈跟踪中分配每个对象的位置，其中包括线程。 要查看应用程序的内存分配，请单击内存分析器工具栏中的Record memory allocations。当它记录时，与你的应用程序进行交互，以引起内存溢出或内存泄漏。完成后，单击Stop recording。 分配的对象列表出现在时间轴下面，按类名称分组，按堆计数排序，如上图所示。 分配跟踪器最多记录65535个分配。如果您的记录超出此限制，则只有最近65535个分配将保存在该记录中。 要检查分配记录，请按照下列步骤操作： 浏览列表以查找具有非常大的堆计数且可能泄漏的对象，要帮助查找已知类，请单击类名列标题按字母顺序排序。然后单击一个类名，Instance View 窗格就会显示在右侧，显示该类的每个实例，如下图所示。 在Instance View窗格中，单击一个实例。Call Stack选项卡显示在下面，显示了哪个实例被分配在哪个线程中。 在Call Stack选项卡中，单击任意行可以在编辑器中跳转到该代码。 默认情况下，列表是按类名排列的。在列表的顶部，您可以使用右下拉菜单在列表之间切换: Arrange by class： 根据类名分配。 Arrange by package：根据包名分配。 Arrange by callstack: 根据调用堆栈排序 2.4 捕获堆转储堆转储显示在捕获堆转储时应用程序正在使用内存的对象。特别是在扩展用户会话之后，堆转储可以通过显示仍然在内存中的对象来帮助识别内存泄漏。捕获堆转储后，可以查看以下内容: 您的应用程序分配了哪些类型的对象，以及每个对象的数量。 每个对象使用多少内存 每个对象的引用被保留在你的代码中。 调用堆栈，用于分配对象的位置（只有在记录分配时捕获堆转储）。 要捕获堆转储，单击Memory-Profiler工具栏中的dump Java堆。在转储堆时，Java内存的数量可能会暂时增加。这是正常的，因为堆转储发生在与应用程序相同的进程中，需要一些内存来收集数据。 堆转储出现在内存时间轴下方，显示堆中的所有类类型，如上图所示。 要检查你的堆，请按照下列步骤操作： 浏览列表以查找具有异常大堆计数的对象，因为它可能会被泄露。为了帮助查找已知类，请单击类名列标题以按字母顺序排序。然后单击类名。实例视图窗格出现在右边，显示该类的每个实例，如下图所示。 在Instance View窗格中，单击一个实例。 References选项卡显示在下面，显示对该对象的所有引用。或者单击实例名称旁边的箭头以查看其所有字段，然后单击字段名称以查看其所有引用。如果要查看某个字段的实例详细信息，请右键单击该字段，然后选择Go to Instance。 在References选项卡中，如果识别可能是内存泄漏的引用，请右键单击它，然后选择Go to Instance.。这将从堆转储中选择相应的实例，显示您自己的实例数据。 默认情况下，堆转储不会显示每个已分配对象的堆栈跟踪。要获取堆栈跟踪，您必须在单击转储Java堆之前开始记录内存分配。如果您这样做，您可以在实例视图中选择一个实例，并在References选项卡旁边看到Call Stack选项卡，如下图所示。但是，在开始记录分配之前，可能已经分配了一些对象，因此这些对象无法使用调用堆栈。包含一个调用堆栈的实例在图标上有一个stack标记。 在classes列表中，您可以看到以下信息： Heap Count: 堆中的实例数。 Shallow Size: 此堆中所有实例的总大小（以字节为单位）。 Retained Size: 这个类的所有实例(以字节为单位)保留的内存总大小。 在类列表的顶部，可以使用左下拉列表在以下堆转储之间切换: Default heap: 当系统没有指定堆时。 App heap: 应用程序分配内存的主堆。 Image heap: 系统引导映像，包含在引导期间预加载的类。这里的分配保证永远不会移动或离开。 Zygote heap: Android系统中分发应用程序进程的写时复制堆 默认情况下，列表按保留大小列排序。您可以单击任何列标题来更改列表的排序方式。 在Instance View中，每个实例包括以下内容： Depth：从任何GC根到所选实例的跳数最短。 Shallow Size：此实例的大小。 Retained Size：此实例支配的内存大小（根据支配者树)。 三、 网络分析器(Network Profiler)网络分析器在时间轴上显示实时网络活动，显示发送和接收的数据，以及当前连接的数量。这让您可以检查应用程序如何和何时传输数据，并适当地优化底层代码。 打开面板的步骤和上面的几乎一致。 3.1 为什么要使用网络分析器当应用程序向网络发出请求时，设备必须使用耗电的移动或WiFi无线电来发送和接收数据包。接收器不仅使用电力传输数据，而且还使用额外的电源打开和保持唤醒。 使用网络分析器，您可以查找频繁的、短的网络活动高峰，这意味着您的应用程序要求网络经常打开，或者长时间保持唤醒，以处理许多短的请求。这一模式表明，您可以通过批处理网络请求来优化应用程序，以改善电池性能，从而减少网络必须打开或接收数据的次数。这也使得网络可以切换到低功率模式，以节省电池的时间间隔。 有关优化应用程序网络活动的技术的更多信息，请参阅 Reducing Network Battery Drain。 3.2 网络分析器概述在窗口的顶部，您可以看到事件时间线和①无线电电源状态(high/low)和wi-fi。在时间轴上，您可以单击和拖动来选择②时间轴的一部分来检查流量。下面的③窗口显示在时间轴的选定部分中发送和接收的文件，包括文件名、大小、类型、状态和时间。您可以通过单击任何列标题来对列表进行排序。您还可以看到时间线所选部分的详细分解，显示每个文件被发送或接收的时间。 单击连接的名称，查看所选文件发送或接收的详细信息。单击④选项卡查看响应数据、头信息或调用堆栈。 提示：您必须启用高级概要分析来选择时间轴的一部分来检查，查看发送和接收的文件的列表，或者查看所选文件发送或接收的详细信息。为了启用高级分析，请查看上一篇文章 3.3 网络连接疑难解答如果网络分析器检测到流量值，但无法识别任何支持的网络请求。您将收到以下错误消息：”Network Profiling Data Unavailable: There is no information for the network traffic you’ve selected.” 目前，网络分析器只支持HttpURLConnection和OkHttp库。如果您的应用程序使用另一个网络连接库，那么您可能无法在网络分析器中查看您的网络活动。如果您已经收到了这个错误消息，但是您的应用程序确实使用HttpURLConnection或OkHttp，请报告错误，以便我们可以调查这个问题。 转载：http://blog.csdn.net/niubitianping/article/details/72617864]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 3中解决androidannotations报错]]></title>
    <url>%2FAndroid%2F2018%2F02%2F06%2FAndroid%2FAndroid%20Studio%203%E4%B8%AD%E8%A7%A3%E5%86%B3androidannotations%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[Android Studio 3中解决androidannotations报错报错最近Fork了一个项目，报以下错误12345Error:Execution failed for task ':sample:javaPreCompileDebug'.&gt; Annotation processors must be explicitly declared now. The following dependencies on the compile classpath are found to contain annotation processor. Please add them to the annotationProcessor configuration. - androidannotations-4.0.0.jar (org.androidannotations:androidannotations:4.0.0) Alternatively, set android.defaultConfig.javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true to continue with previous behavior. Note that this option is deprecated and will be removed in the future. See https://developer.android.com/r/tools/annotation-processor-error-message.html for more details. 解决方法在app目录下的gradle文件中添加 &#123;1234 annotationProcessorOptions &#123; includeCompileClasspath = true &#125;&#125; 变为 123456789101112131415161718android &#123; compileSdkVersion 25 buildToolsVersion "26.0.2" defaultConfig &#123; minSdkVersion 11 targetSdkVersion 25 versionCode 3 versionName "3.0.0" javaCompileOptions &#123; annotationProcessorOptions &#123; includeCompileClasspath = true &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>问题解决</tag>
        <tag>Android Studio</tag>
        <tag>androidannotations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 3中解决butterknife:7报错的问题]]></title>
    <url>%2FAndroid%2F2018%2F02%2F06%2FAndroid%2FAndroid%20Studio%203%E4%B8%AD%E8%A7%A3%E5%86%B3butterknife%3A7%E6%8A%A5%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Android Studio 3中解决butterknife:7报错的问题最近从GitHub上Fork了一个项目任阅，用Android Studio3 打开后Android Studio 3.0中android-apt切换为官方annotationProcessor解决apt的问题后butterknife又有问题。 报错： 12345Error:Execution failed for task ':app:javaPreCompileDebug'.&gt; Annotation processors must be explicitly declared now. The following dependencies on the compile classpath are found to contain annotation processor. Please add them to the annotationProcessor configuration. - butterknife-7.0.1.jar (com.jakewharton:butterknife:7.0.1) Alternatively, set android.defaultConfig.javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true to continue with previous behavior. Note that this option is deprecated and will be removed in the future. See https://developer.android.com/r/tools/annotation-processor-error-message.html for more details. 解决办法：加上 annotationProcessor ‘com.jakewharton:butterknife:7.0.1’即可解决 12 compile 'com.jakewharton:butterknife:7.0.1'+ annotationProcessor 'com.jakewharton:butterknife:7.0.1' 参考：https://www.jianshu.com/p/09dc882a9fad]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>问题解决</tag>
        <tag>Android Studio</tag>
        <tag>butterknife</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 3.0中解决apt报错，android-apt切换为官方annotationProcessor]]></title>
    <url>%2FAndroid%2F2018%2F02%2F06%2FAndroid%2FAndroid%20Studio%203.0%E4%B8%AD%E8%A7%A3%E5%86%B3apt%E6%8A%A5%E9%94%99%EF%BC%8Candroid-apt%E5%88%87%E6%8D%A2%E4%B8%BA%E5%AE%98%E6%96%B9annotationProcessor%20%2F</url>
    <content type="text"><![CDATA[Android Studio 3.0中解决apt报错，android-apt切换为官方annotationProcessor最近从GitHub上Fork了一个项目任阅，用Android Studio3 打开后 报错1234567891011121314151617181920212223242526Error:Cannot choose between the following configurations of project :EasyAdapterLibrary: - debugApiElements - debugRuntimeElements - releaseApiElements - releaseRuntimeElementsAll of them match the consumer attributes: - Configuration 'debugApiElements': - Found com.android.build.api.attributes.BuildTypeAttr 'debug' but wasn't required. - Found com.android.build.gradle.internal.dependency.AndroidTypeAttr 'Aar' but wasn't required. - Found com.android.build.gradle.internal.dependency.VariantAttr 'debug' but wasn't required. - Found org.gradle.api.attributes.Usage 'java-api' but wasn't required. - Configuration 'debugRuntimeElements': - Found com.android.build.api.attributes.BuildTypeAttr 'debug' but wasn't required. - Found com.android.build.gradle.internal.dependency.AndroidTypeAttr 'Aar' but wasn't required. - Found com.android.build.gradle.internal.dependency.VariantAttr 'debug' but wasn't required. - Found org.gradle.api.attributes.Usage 'java-runtime' but wasn't required. - Configuration 'releaseApiElements': - Found com.android.build.api.attributes.BuildTypeAttr 'release' but wasn't required. - Found com.android.build.gradle.internal.dependency.AndroidTypeAttr 'Aar' but wasn't required. - Found com.android.build.gradle.internal.dependency.VariantAttr 'release' but wasn't required. - Found org.gradle.api.attributes.Usage 'java-api' but wasn't required. - Configuration 'releaseRuntimeElements': - Found com.android.build.api.attributes.BuildTypeAttr 'release' but wasn't required. - Found com.android.build.gradle.internal.dependency.AndroidTypeAttr 'Aar' but wasn't required. - Found com.android.build.gradle.internal.dependency.VariantAttr 'release' but wasn't required. - Found org.gradle.api.attributes.Usage 'java-runtime' but wasn't required. 原因从Messages中并没有查看出是什么原因，但是此项目之前使用的AS2.1，并且gradle中使用了apt，所以我怀疑是Studio升级到3.0之后原来的配置方式apt与最新版本Gradle已经不兼容。 APTAPT(Annotation Processing Tool)是一种处理注释的工具,它对源代码文件进行检测找出其中的Annotation，使用Annotation进行额外的处理。Annotation处理器在处理Annotation时可以根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由Annotation处理器的编写者决定),APT还会编译生成的源文件和原来的源文件，将它们一起生成class文件。 Android Gradle插件2.2版本发布后，Android 官方提供了annotationProcessor来代替android-apt，annotationProcessor同时支持 javac 和 jack 编译方式，而android-apt只支持 javac 方式。同时android-apt作者宣布不在维护，当然目前android-apt仍然可以正常运行，如果你没有想支持 jack 编译方式的话，可以继续使用 android-apt。Android Studio 3.0执行android-apt报错： Android Studio 3.0执行android-apt一般会报错： 1Error:android-apt plugin is incompatible with the Android Gradle plugin. Please use 'annotationProcessor' configuration instead. 解决android-apt切换为官方annotationProcessor的方法 1、 在build.gradle修改为Android Gradle 3.0 插件 1234567891011buildscript &#123; repositories &#123; ... google() &#125;- classpath 'com.android.tools.build:gradle:2.1.0'+ classpath 'com.android.tools.build:gradle:3.0.1' &#125;&#125; 2、删除build.gradle里android-apt 的相关配置 项目目录下 123456789101112 buildscript &#123; repositories &#123; maven&#123; url 'http://maven.aliyun.com/nexus/content/groups/public/'&#125; jcenter() &#125; dependencies &#123;- classpath 'com.android.tools.build:gradle:2.1.0'- classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'+ classpath 'com.android.tools.build:gradle:3.0.1'+ // classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8' &#125; &#125; app目录下 plugin: 'com.android.application'123456- apply plugin: &apos;android-apt&apos;+ //apply plugin: &apos;android-apt&apos; android &#123; compileSdkVersion 23 buildToolsVersion &quot;23.0.3&quot; 3、替换build.gradle里旧的配置为新的配置 做以下替换 compile 改为 implementation, apt 改为 annotationProcessor testCompile 改为 androidTestImplementation app目录下 'com.squareup.okhttp3:okhttp:3.2.0'12345678 // Annotation- compile &apos;com.google.dagger:dagger:2.0.2&apos;- apt &apos;com.google.dagger:dagger-compiler:2.0.2&apos;+// compile &apos;com.google.dagger:dagger:2.0.2&apos;+// apt &apos;com.google.dagger:dagger-compiler:2.0.2&apos;+ implementation &apos;com.google.dagger:dagger:2.9&apos;+ annotationProcessor &apos;com.google.dagger:dagger-compiler:2.9&apos;+ 4、清理缓存并重启Android Studio 3.0 5 扩展同样适用于一下报错信息的解决 1Error:android-apt plugin is incompatible with the Android Gradle plugin. Please use 'annotationProcessor' configuration instead. 参考：https://www.jianshu.com/p/c1666a947692https://majing.io/posts/10000003001155]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>问题解决</tag>
        <tag>Android Studio</tag>
        <tag>apt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RelativeLayout、Framelayout 两布局重叠,使下层不响应点击事件]]></title>
    <url>%2FAndroid%2F2018%2F01%2F23%2FAndroid%2FRelativeLayout%E3%80%81Framelayout%20%E4%B8%A4%E5%B8%83%E5%B1%80%E9%87%8D%E5%8F%A0%2C%E4%BD%BF%E4%B8%8B%E5%B1%82%E4%B8%8D%E5%93%8D%E5%BA%94%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[RelativeLayout、Framelayout 两布局重叠,使下层不响应点击事件123456789101112131415161718192021222324252627282930代码段A&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ListView android:id="@+id/listview" android:layout_width="match_parent" android:layout_height="match_parent" android:divider="@null" android:fadingEdge="none" android:listSelector="@android:color/transparent" android:scrollbars="none" /&gt; &lt;LinearLayout android:id="@+id/search_container" android:layout_height="match_parent" android:layout_width="match_parent" android:visibility="gone" android:orientation="vertical" android:background="@android:color/darker_gray"&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; FrameLayout、RelativeLayout，代码中控件代码的的位置越靠后，此控件越会显示在层叠布局的上方。 代码段B的布局会动态加载到代码段A的search_container中，并且形成重叠布局，此时 markView 会遮盖listView，但是点击事件会穿透markView传递给listView。 123456789101112131415代码段B&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;View android:id="@+id/markView" android:layout_width="match_parent" android:layout_height="match_parent" android:alpha="0.5" android:background="@color/black" /&gt;&lt;/LinearLayout&gt; 怎样解决这个问题呢？ 代码段B 增加一行代码 android:clickable=&quot;true&quot; 变成这样123456789101112131415代码段C&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:clickable="true" android:orientation="vertical" &gt; &lt;View android:layout_width="match_parent" android:layout_height="match_parent" android:alpha="0.5" android:background="@color/black" /&gt;&lt;/LinearLayout&gt;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>问题解决</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用GitBook制作一本书（从GitHub导入创建一本书）]]></title>
    <url>%2FGit%2F2018%2F01%2F12%2FVersionControl%2F2018-01-12%2F</url>
    <content type="text"><![CDATA[1创建一个Github Repositoryhttps://github.com/new 2创建一本书https://www.gitbook.com/new 选择从Github导入2.Github授权 3 导入Github Repository作为书籍再次回到https://www.gitbook.com/new， 填写Book信息，选择你要导入的Github Repository 这个页面目前是在同步，等同步完毕后，就可以看到自己的书了。 4去编辑自己的书吧可以在浏览器编辑，也可以在客户端编辑 参考：http://blog.csdn.net/hk2291976/article/details/51173850]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>GitBook</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo创建文章和草稿]]></title>
    <url>%2FReactNative%2F2018%2F01%2F12%2FReactNative%2F2018-01-12%2F</url>
    <content type="text"><![CDATA[JavaScript语法let以及let与var的区别let 语句声明一个块级作用域的本地变量，并且可选的将其初始化为一个值。 语法let var1 [= value1] [, var2 [= value2]] [, …, varN [= valueN]]; 参数var1, var2, …, varN 变量名。可以是任意合法的标识符。 value1, value2, …, valueN 变量的初始值。可以是任意合法的表达式。 描述let允许你声明一个作用域被限制在块级中的变量、语句或者表达式。与var关键字不同的是，它声明的变量只能是全局或者整个函数块的。 这里解释了我们为什么选取“let”这个名字。 12345678Let is a mathematical statement that was adopted by early programming languages like Scheme and Basic. Variables are considered low level entities not suitable for higher levels of abstraction, thus the desire of many language designers to introduce similar but more powerful concepts like in Clojure, F#, Scala, where let might mean a value, or a variable that can be assigned, but not changed, which in turn lets the compiler catch more programming errors and optimize code better. JavaScript has had var from the beginning, so they just needed another keyword, and just borrowed from dozens of other languages that use let already as a traditional keyword as close to var as possible, although in JavaScript let creates block scope local variable instead. answered Jun 20 ‘16 at 7:47 exebook 123456Let是一个数学声明，是采用于早期的编程语言如Scheme和Basic。变量被认为是不适合更高层次抽象的低级实体，因此许多语言设计者希望引入类似但更强大的概念，如在Clojure、f#、Scala，let可能意味着一个值，或者一个变量可以赋值，但不能被更改，这反过来使编译器能够捕获更多的编程错误和优化代码更好。javascript从一开始就有var，所以他们只是需要另一个关键字，并只是借用了其他数十种语言，使用let已经作为一个传统的尽可能接近var的关键字，虽然在javascript 中 let只创建块范围局部变量而已。 作用域规则let声明的变量只在其声明的块或子块中可用，这一点，与var相似。二者之间最主要的区别在于var声明的变量的作用域是整个封闭函数。 1234567891011121314151617function varTest() &#123; var x = 1; if (true) &#123; var x = 2; // 同样的变量! console.log(x); // 2 &#125; console.log(x); // 2&#125;function letTest() &#123; let x = 1; if (true) &#123; let x = 2; // 不同的变量 console.log(x); // 2 &#125; console.log(x); // 1&#125; 简化内部函数代码当用到内部函数的时候，let会让你的代码更加简洁。 1234567891011121314151617181920212223242526var list = document.getElementById('list');for (let i = 1; i &lt;= 5; i++) &#123; let item = document.createElement('li'); item.appendChild(document.createTextNode('Item ' + i)); item.onclick = function(ev) &#123; console.log('Item ' + i + ' is clicked.'); &#125;; list.appendChild(item);&#125;// to achieve the same effect with 'var'// you have to create a different context// using a closure to preserve the valuefor (var i = 1; i &lt;= 5; i++) &#123; var item = document.createElement('li'); item.appendChild(document.createTextNode('Item ' + i)); (function(i)&#123; item.onclick = function(ev) &#123; console.log('Item ' + i + ' is clicked.'); &#125;; &#125;)(i); list.appendChild(item);&#125; 以上示例的工作原理是因为（匿名）内部函数的五个实例引用了变量i的五个不同实例。注意，如果你将let替换为var，则它将无法正常工作，因为所有内部函数都将返回相同的i：6的最终值。此外，我们可以通过将创建新元素的代码移动到每个循环的作用域来保持循环更清晰。 在程序或者函数的顶层，let并不会像**var**一样在全局对象上创造一个属性，比如： 1234var x = 'global';let y = 'global';console.log(this.x); // "global"console.log(this.y); // undefined 模仿私有接口在处理构造函数的时候，可以通过let绑定来共享一个或多个私有成员，而不使用闭包： 123456789101112131415161718192021222324252627282930313233343536var Thing;&#123; let privateScope = new WeakMap(); let counter = 0; Thing = function() &#123; this.someProperty = 'foo'; privateScope.set(this, &#123; hidden: ++counter, &#125;); &#125;; Thing.prototype.showPublic = function() &#123; return this.someProperty; &#125;; Thing.prototype.showPrivate = function() &#123; return privateScope.get(this).hidden; &#125;;&#125;console.log(typeof privateScope);// "undefined"var thing = new Thing();console.log(thing);// Thing &#123;someProperty: "foo"&#125;thing.showPublic();// "foo"thing.showPrivate();// 1 let暂存死区的错误在相同的函数或块作用域内重新声明同一个变量会引发SyntaxError。 1234if (x) &#123; let foo; let foo; // TypeError thrown.&#125; 在 ECMAScript 2015 中，**let**绑定不受变量提升的约束，这意味着**let**声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前，引用它将会导致 [ReferenceError](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError)（而使用 var 声明变量则恰恰相反，该变量的值是 undefined ）。该变量处于从块开始到初始化处理的“暂存死区”。 123456function do_something() &#123; console.log(bar); // undefined console.log(foo); // ReferenceError: foo is not defined var bar = 1; let foo = 2;&#125; 在 switch 声明中你可能会遇到这样的错误，因为它只有一个块. 123456789switch (x) &#123; case 0: let foo; break; case 1: let foo; // TypeError for redeclaration. break;&#125; 但是，重要的是要指出嵌套在case子句内的块将创建一个新的块作用域的词法环境，这不会产生上面显示的重新声明错误。 123456789101112let x = 1;switch(x) &#123; case 0: &#123; let foo; break; &#125; case 1: &#123; let foo; break; &#125;&#125; 与词法作用域结合的暂存死区由于词法作用域，表达式(foo + 55)内的标识符“foo”会解析为if块的foo，而不是覆盖值为33的foo。在这一行中，if块的“foo”已经在词法环境中创建，但尚未达到（并终止）其初始化（这是语句本身的一部分）：它仍处于暂存死区。 1234567function test()&#123; var foo = 33; if (true) &#123; let foo = (foo + 55); // ReferenceError &#125;&#125;test(); 这种现象可能会使您陷入以下情况。指令let n of n.a已经在for循环块的私有范围内，因此标识符“n.a”被解析为位于指令本身的第一部分（“let n”）中的’n’对象的属性’a’ ，由于尚未达成和终止其声明，因此仍处于暂存死区。 12345678910function go(n) &#123; // n here is defined! console.log(n); // Object &#123;a: [1,2,3]&#125; for (let n of n.a) &#123; // ReferenceError console.log(n); &#125;&#125;go(&#123;a: [1, 2, 3]&#125;); 其他情况当在块中使用时，let将变量的作用域限制为该块。注意**var**的作用域在它被声明的函数内的区别。 12345678910111213var a = 1;var b = 2;if (a === 1) &#123; var a = 11; // the scope is global let b = 22; // the scope is inside the if-block console.log(a); // 11 console.log(b); // 22&#125; console.log(a); // 11console.log(b); // 2 规范| Specification | Status | Comment || ECMAScript 2015 (6th Edition, ECMA-262) Let and Const Declarations | Standard | Initial definition. Does not specify let expressions or let blocks. || ECMAScript Latest Draft (ECMA-262) Let and Const Declarations | Living Standard | | 浏览器兼容 Desktop Mobile Feature Chrome Edge Firefox Internet Explorer Opera Safari Basic support 41 12 441 2 3 11 17 10 1. Prior to Firefox 44, let is only available to code blocks in HTML wrapped in a &lt;script type=&quot;application/javascript;version=1.7&quot;&gt; block (or higher version) and has different semantics (e.g. no temporal dead zone). 2. Prior to Firefox 46, a TypeError is thrown on redeclaration instead of a SyntaxError. 3. Firefox 54 adds support of let in workers. 相关链接 var const ES6 In Depth: let and const Breaking changes in let and const in Firefox 44. You Don’t Know JS: Scope &amp; Closures: Chapter 3: Function vs. Block Scope 文档标签和贡献者 标签： ECMAScript 2015 JavaScript let Statement Variable declaration Variables 参考：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ECMAScript 2015</tag>
        <tag>JavaScript</tag>
        <tag>let</tag>
        <tag>Statement</tag>
        <tag>ES6</tag>
        <tag>Variable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac和Linux返回上一级的命令是什么]]></title>
    <url>%2FMac%2F2018%2F01%2F12%2FMac%2F2018-01-11%2F</url>
    <content type="text"><![CDATA[Mac和Linux返回上一级的命令是什么要注意在linux shell有几个特定的符号。一个就是 . 指当前目录，例如： sh ./xx就是用shell去运行当前目录下的xx程序。一个是 .. 指上一级目录，例如： vi ../xx就是用vi去打开上一级目录下的xx文件。 cd ..将上一级目录变为当前目录，也就是返回上一级。另外就是 ~ 代表当前用户的家目录。 cd ~回到登录用户的家目录。参考：https://zhidao.baidu.com/question/58838894]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>命令行</tag>
        <tag>Terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ListView的Item会出现点击两次的问题]]></title>
    <url>%2FAndroid%2F2018%2F01%2F10%2F2018-01-10%2F</url>
    <content type="text"><![CDATA[Android ListView的Item会出现点击两次的问题方案有两种，方案一： 直接自定义监听器，适用于大量此类操作。方案二： 直接在方法里拦截，适用于少量此类操作。 方案一：自定义一个监听器NoDoubleClickListener，抽象一个 onNoDoubleClick 方法。 1234567891011121314151617public abstract class NoDoubleClickListener implements View.OnClickListener &#123; public static final int DELAY = 10000; //连击事件间隔 private long lastClickTime = 0; //记录最后一次时间 @Override public void onClick(View v) &#123; long currentTime = System.currentTimeMillis(); if (currentTime - lastClickTime &gt; DELAY) &#123; //判断时间差 lastClickTime = currentTime; //记录最后一次点击时间 onNoDoubleClick(v); &#125; &#125; //抽象一个无连击事件方法，用于实现内容 public abstract void onNoDoubleClick(View v);&#125; 用法，在建立监听的时候使用刚刚自定义的监听器，并实现其抽象方法。 1234567view.setOnClickListener(new NoDoubleClickListener() &#123; @Override public void onNoDoubleClick(View v) &#123; //你的代码 &#125; &#125;); 方案二：把方案一的时间差判定方法拿出来。。就行了。。 1234567891011public class Utils &#123; public static final int DELAY = 1000; private static long lastClickTime = 0; public static boolean isNotFastClick()&#123; long currentTime = System.currentTimeMillis(); if (currentTime - lastClickTime &gt; DELAY) &#123; lastClickTime = currentTime; return true; &#125;else&#123;return false;&#125; &#125;&#125; 用法, 12345678view.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; if(Utils.isNotFastClick())&#123; //你的代码 &#125; &#125; &#125;); 按照java的设计原则，推荐第一种方案。其他监听也是同样的自定义方式。 参考：https://segmentfault.com/q/1010000004395999]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ListView</tag>
        <tag>问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网]]></title>
    <url>%2F%E7%A8%8B%E5%BA%8F%E5%91%98%2F2018%2F01%2F04%2F%E7%A8%8B%E5%BA%8F%E5%91%98%2F2018-02-23%2F</url>
    <content type="text"><![CDATA[科学上网输入我的邀请码 YGHQJR9 来获得三个月的蓝灯专业版！立即下载 https://github.com/getlantern/forum]]></content>
      <categories>
        <category>程序员</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员应该知道的10种软件]]></title>
    <url>%2F%E7%A8%8B%E5%BA%8F%E5%91%98%2F2018%2F01%2F04%2F%E7%A8%8B%E5%BA%8F%E5%91%98%2F2018-01-04%2F</url>
    <content type="text"><![CDATA[程序员应该知道的10种软件除非你是设计小型模拟电子电路，不然这年头离开了计算机的帮助，在嵌入式系统设计中很难做成什么事。我觉得我应该分享一个能帮助我完成工作的软件工具列表。它们大多数都是免费的或者比较便宜的。它们大多数也和软件一起工作。如果你向来不需要设计，阅读或者编辑任何软件，那么你属于读了这篇文章不会从中受益的那一小部分人。 免责声明：“最佳”软件工具通常是一种主张。你可能不同意我的主张，那就取其精华吧。 1. 版本控制不管你工作在一个100人的团队，还是独自一人干活，如果你从事设计，你应该会用到版本控制软件。这是一种可以管理文档的不同版本的软件，不管是图表还是源代码。像源代码或配置文件这样的文本文档尤其适合于版本控制，因为很容易查看版本间的差异，合并两个版本之间的改动，特别是多个人工作在一组文档上。 版本控制里的文档集合称为版本库（repository）。版本库所在的位置某种程度上取决于你用什么样的版本控制系统——基本上有两类版本控制系统：集中式和分布式。集中式版本控制包含一个存放版本库的服务器。当你方便的时候，你提交你的修改到版本库里。分布式版本控制系统（DVCS）不需要中央服务器：每个人工作在有他们自己的本地缓存的版本库上（包括整个历史记录），可能会从一个版本库传送新的提交到另一个版本库，通过在原版本库上“push”或者在目标版本库上“pull”完成。 2012年开源社区里最流行的三个版本控制系统是Subversion（SVN），Mercurial（hg）和Git。Subversion是集中式的，而Mercurial和Git是分布式的。 我用Mercurial开发个人软件。建立版本库很简单。到你工作的根目录下输入hg init，然后用hg add添加你喜欢的文件，然后用hg commit提交。我只需要花几分钟，立马就能够回退到某个文件的早期版本。我会专门为我家里PC机上的服务配置文件（例如Apache网站服务器）这样做——如果我修改了一个文件，并且这个修改引起了一个bug，我只用回退到该文件的早期版本就可以了。 如果项目只有你一个人在做，管理版本控制系统容易得不可思议——只需要在较好的暂停点时不时进行提交。如果你和别人一起工作，当你们中的一个人做出修改而另一个人做出不同的修改产生冲突时，有几种方法来协调。就是所谓的“合并”。对于文本文档，只要你经常这样做，通常很容易。对于二进制文件，几乎不可能。比较合适的处理方式是在库里的文件上放置一道锁，清楚地声明你工作在一个特殊的文件上，并且其他人不应该工作在这个文件上。 这三个系统（svn，hg和git）起先全都是命令行工具，但是它们都有各式各样的图形用户界面前端，包括Tortoise系列的用户界面。那是一个在你的操作系统的文件浏览器（如Windows Explorer或者Mac OSX Finder）上扩展的轻量级组件。它们不如非免费的版本控制系统那样易用。我们工作中用过SurroundSCM，当我有点不太喜欢后端的行为方式时，我发现Surround UI在协调分支间的差异上更加好用。 还值得注意的是有很多版本库在线主机系统，有bitbucket.org，SourceForge，Google Code和GitHub。它们全都为公开版本库提供免费的主机服务。bitbucket免费为项目成员不超过5人的私有版本库提供主机服务。我强烈推荐使用像Mercurial或者Git这样的分布式版本控制系统，因为这意味着你可以把项目从一个主机站点转到另一个上，并且即使站点临时宕机，你依旧可以使用本地的版本库的拷贝。 2. 文件比较工具在将代码合并到版本控制系统中，或者仅仅是想看看一个文件同另一个文件之间的差异时，你会需要文件比较工具。有命令行的工具如“diff”，还有图形用户界面的文件比较工具。我喜欢叫Beyond Compare的程序——不是免费的，但是不贵，并且易用。它还可以比较两个文件夹，可以让你做3-way文件比较。Beyond Compare有Windows和Linux的，OSX版本的正在开发但是现在还没有。其他的还有SourceGear DiffMerge（免费，跨平台 Win/OSX/Linux），Compare It!（便宜，只有Windows的），DeltaWalker（价格适中，OSX）和UltraCompare（价格适中，跨平台）。 3. 编辑器和文本文件打交道可难可易，这取决于你用的软件。重量级的编辑器是像Eclipse，NetBeans或者Visual Studio那样的集成开发环境（IDE）。假如你用特定的软件工具和在特殊的处理器上编程，那么它们很出色。但是有时候你需要的只是快速编辑文件。操作系统自带的基本编辑器（像Windows上的记事本，Mac上的TextEdit）是轻量级的，但他们没有多少功能。我喜欢有中量级的编辑器可以用：这个类目里有一些好的免费编辑器，如Windows上的Notepad++，Mac上的TextWrangler。我还用过非免费的UltraEdit，它更强大一点，而且在Windows，OSX，Linux上都可以用。SlickEdit是专业级的编辑器，要价数百美元，可能对绝大多数任务杀伤力过大，但我的一些同事却很忠于它。（希望他们没有吐槽它） 提到编辑器不提GNU emacs就不公平了——它是免费的开源的编辑器，诞生于当大多数操作系统还是基于终端的时候。它的大多数命令都是用一串难以理解的按键发出。你喜欢这样的方式就行，我是不喜欢的。它是一个非常强大的编辑器，可以通过Lisp语言编程定制。你可以在emacs里做任何事，只要它是可以在终端显示的。 我要找的编辑器的两大功能如下： 大文件支持。如果很大的文件（若干兆），确保你的编辑器可以在不用把文件全部加载到内存就能打开它。记事本不行，但是Notepad++和UltraEdit可以。 “多文件查找”功能 典型的源代码树包含多个文件，你经常会忘记把东西放哪了。（好吧，至少我会忘记把东西放哪了！）在多个文件里搜索一个单词或模式的能力是无价的。Unix的“grep”允许你用命令行做这样的事，但是编辑器里的“多文件查找”功能可以让你双击查找结果，然后跳到编辑器里的该行上。 你可能还需要在十六进制编辑器里编辑二进制文件——可以让你查看和编辑那些不可打印字符的字符码。Notepad++和UltraEdit都有十六进制编辑模式。如果你用Mac，试试单机版的Hex Fiend——它很不错。 还有用于XML文件的特殊编辑器——在免费类目里，有XML Notepad和firstobject的XML编辑器“foxe”。foxe的用户界面有点笨拙，但是用来编辑大型文件非常非常不错。 4. Build 工具如果你开始在IDE里写软件，只用点击”构建“，然后程序就给你编译你的源代码。这样做要注意，它意味着你在让IDE去操心那些细节。对于你正在其中学习某个东西的小系统倒还好。但是有大量的选项可以改变软件的编译方式，在IDE里它们被埋藏在菜单里，并且也不容易从一个项目转移到另一个项目。运气好的话，你可以识别出用于存储构建配置的那些文件，然后可以检入到版本控制系统，因为不然的话你保存的不是完整的项目源码。 专业的软件工程师——重申，这是一家之言——应该用一种明确的构建工具。标准的原味的（plain-vanilla）解决方案（我宁愿错打成痛苦味的pain-vanilla，并这样保持下去）是一个在70年代引入的叫做make的程序。不幸的是它现在仍被在用。makefile由像这样若干行构成： foo.obj: foo.ccc -o $@ $&lt; 它们是一些规则，告诉make如何通过执行程序（这个例子里是“cc”）把源文件（例如上面的“foo.c”）变成目标文件（例如“foo.obj”）来构建你的软件。它们还指示依赖关系：假设文件F3依赖于运行命令X从文件F2生成文件F3，文件F2依赖于运行命令Y从文件F1生成文件F2——构建工具要能够推断出依赖关系图，这样如果你改变了文件F1，它能够知道必须相应地重新构建文件F2和文件F3。这可能看起来微不足道，但是在任何项目里，除了那种微型软件项目，这都是相当重要的。我从事的是相对简单的软件项目，它只有数十个源文件，但是全部编译需要5分钟。有合适的构建工具正确的捕获依赖关系，根据你做的修改，让你只增量编译那些有需要的文件。 make有很多短板。别的不说，makefile的语法很含糊，你在编译时需要做特殊处理的地方，它难以处理这种特殊情况，你不去为此写一些单独的脚本是不行的。 对于Java程序而言，标准工具是ant和maven。它们让事情更容易，还可以用来构建Java程序之外的其他系统，但是在一般开发环境下不经常用到。 还有很多其他的构建工具。过去的几年里，我开始将我的偏好从陈述性语法（如makefile和ant脚本）的工具转移到更加多用途的语法的工具上。这样的想法是因为对于大多数简单的任务，你可以描述得非常简明，但是如果你想要做点复杂的事，你拥有多用途编程语言的全部威力。（举个例子，如果你想在一个特殊的构建任务里启用命令行选项“-On”，这里“n”是一个数字，等于文件的大小模以7。你可以写一个自动做这个的方法）这些工具包括rake（基于Ruby），gradle（基于Groovy），scons和waf（它俩都基于Python）。我用了scons三年，因为我懂Python。是一个同事给我推荐的scons。它在某些地方工作的很好，并且极其灵活，但是在其他地方真的难以去修改scons的默认行为，让它做你真正要做的。最近我刚开始用waf。我发现更容易让它做我需要做的，因此如果你有一个新项目，我推荐你看看waf，尽管我希望它有一个不这么神秘的名字。 5. 脚本工具有时候你需要快速组装一段软件来做某件事。通常很难用C或者C++来实现，因为你必须花费精力写代码来解析字符串，或者读文件，或者任何别的什么。然后你得为每个计算机平台把这个C/C++程序编译成可执行文件。啊… 更好的解决方案是使用脚本语言。它们通常都是解释性的计算机语言，解释器提供了大多数操作系统的版本。所以如果你写了一个脚本，应该可以用在不同的操作系统上。 现代脚本语言的例子是Python，Ruby和Groovy。（我更喜欢Python。）早期的脚本语言包括awk和Perl。我有一些避免使用Perl的理由：它的语法非常奇特和神秘，不同的类型有不同的前缀（$foo是一个单变量，但是@foo是一个数组），还有它鼓励使用“伪变量”（&lt;&gt;和$_），它的一些副作用隐含地依赖于程序里其他被执行的动作。这些造就了不良的编程风格：编写简短而神秘的脚本，它可以用几行标点符号聪明地完成一些事，但是别人阅读和维护都不易。我惭愧地承认10年前我大量使用awk，因为它比perl简单。awk是一种古老的文本处理脚本语言，曾经有它的地位，但是在某些角度和Perl一样糟糕，都鼓励不好的编程实践。 不管你喜欢哪个，我会强烈建议你用一种能够在调试器里测试的语言。我用awk的经历很糟糕，调试程序的时候我不得不放一些打印语句在里面，告诉我发生什么了。用Python就很开心，因为有一个很好的Eclipse的插件叫做pydev。用它你可以在脚本任何地方设置断点和单步调试。 我时不时也用一个叫做JSDB的程序。JSDB是一个独立的JavaScript的外壳程序，用创立于Firefox网页浏览器的SpiderMonkey JavaScript引擎构建。它还有一些访问文件，数据库，网络流和串行端口等等的工具类。它没有解释性的调试器（尽管有一个奇怪的调试器。该调试器有一种即时网络服务器，你可以把你的网页浏览器指向你计算机上的一个端口，它就可以让你调试程序），并且有时候有一点诡异，但是它比起Python更轻量级，对于有些事情，我发现我能更快着手。 我在这节所提到的所有脚本语言都是免费的。 6. 数值分析工具 除非你做的东西像能够联网的交通灯这种真的很简单，否则有这种可能就是你在嵌入式系统项目里的做某种数学部分。你也许要给数据作图，或者为数据拟合曲线，或者解方程，或者设计一个低通滤波器，或者观察当你修改参数后你的系统改变了多少。在这些任务上数值分析工具可以帮到你。它们包括MATLAB，Mathematica，和MathCAD这样的程序。它们都不是免费的。完全版的MATLAB还有它的全套工具箱会花掉你数千美元，不过它们提供了大量的功能。MATLAB擅长于数据分析，Mathematica擅长符号代数。MathCAD介于两者之间，是所见即所得的处理方式：用来得到你在MathCAD的工作表（worksheet）里所见到的输出的每个运算，在该工作表上你都能看到。因此它一目了然。如果你给谁打印这个工作表，他/她能看到要去复制你的工作成果所需的所有计算步骤。例如和Excel工作表比较，你看到的是运算的结果。要想看的运算步骤，你需要到每一个单元格里去看是否有公式。 MATLAB也有一些“山寨”免费软件：SciLab，Octave和PyLab。它们都提供了MATLAB提供的基本功能，语法也要么一样，要么很相似。但是没有一个像MATLAB那样优美和专业。PyLab的额外的卖点是用Python语言实现，还有为Python提供了科学计算和作图的库。因此如果你懂Python，你可以利用这些知识去进行科学计算。 我对MATLAB是爱恨交加的关系。一方面，它是如此美丽的软件，让你做数值分析，可视化，还有额外的包罗万象的工具箱（信号处理，滤波器设计，控制回路仿真，等等）。另一方面，它不便宜，在MathWorks里的那些出售MATLAB的人们在炫耀他们最新的功能时乐呵呵的好像价格是不需要考虑的。 关于数值分析工具，我有最后一句恳求的咆哮体 不要用Excel进行数值分析！！！ 1996年我开始工作时还是一个电气工程师，我还不懂MATLAB，所以当我要给数据作图时，我用我所知道的：微软Excel。Excel是主要针对商业应用的电子表格软件，但是它可以读文字分割文件（如逗号分隔值CSV文件），有某种控制绘图的方式能让你给结果作图，因此它可以用于给数据图像化。但是如果要做任何超出基本绘制的事情，你会发现要这样非常困难，并且很快就会令人沮丧。如果你有一组数据要图像化，或许不是那么糟糕，而且你可以交互式的让它变成你想要的样子。如果你有一批数据文件想要用同样的方式绘图，真的是个很大的麻烦，你要手动地反反复复去做同样的事情直到结束。当然，你可以用Visual Basic编写宏代码。当我想要在一个页面上做多个图，并对齐坐标轴时我就这么做过。但是接着你会发现你所知道的对象模型既变态又古怪，可能不能让你做你想要做的。然后你便开始对住在华盛顿雷德蒙的某些人起了坏念头。在Excel里如果你遇到了要写宏代码的时候，停下来想想你的情况。那些你投入在让Excel做你要做的事情的时间，你可以花在学习其他能更容易绘图和分析数据的，用于科研而不是商业的软件上。记住，在微软的那些人试图制作能销售和上市的软件，人们用这样的软件可以解决他们的问题。而作为工程师，我们得到的不管什么样的功能刚好是在给自己增加困难。 7. 文档工具你经常会和其他人交流你的想法，有很多不同类型的软件可以帮助你做这个。是的，有不免费的微软程序像用于流程图/绘图的Visio，写文档的Word，还有演讲用的PowerPoint。但是有时候你想要免费的或者更专门的东西，用于特殊类型的文档。 图形可视化 我们不是在此谈x-y图，而是能够可视化带有节点和边的网络。我用graphviz（基于命令行的）和yEd（交互式的）。这两个我都推荐。 序列图 他们让你可视化用例，即一串引起软件组件交互的事件。Quick Sequence Diagram Editor是一个很基本而又可以帮助你画这些图的工具。 “排版”工具（不是生产文档的所见即所得的软件）——docutils和sphinx都能根据ReStructured Text（一种维基风格的标记语言）生成Python风格的文档。所需的生成代码文档的工作量是很少的，尽管两者都能为Python缩进，将它们用于任何其他文档也不难。我前不久放弃了Tex和LaTex，但那是我个人的怪癖，这两个在科研圈子里大量用到。所以你能在那里找到很多支持。还有DocBook。或者你可以寻求所见即所得软件，但是要小心。 “自文档化”代码工具：Doxygen是其中最常见的，把你代码里的注释转为文档。Javadoc是专门用于Java的文档工具。 8. 终端和通讯软件：当你需要经由串口通讯时，到了该用终端软件的时候了。在网页浏览器之前，这更加常见。哪个软件好？朋友不会让朋友使用绑定Windows的超级终端版本——它不是那么健壮——而且微软最终发布Vista时不再捎上它了。我最喜欢的是PuTTYtel和TeraTerm Pro。 其他通讯软件处理FTP和其安全变种SFTP以及SCP。照我看Cyberduck无疑是胜者——非常易用，最开始只在Mac上，现在OSX和Windows上都有。（此外，你如何能不喜欢上一个将橡皮鸭作为logo的软件呢） 9. 软件质量保证（QA）工具：如果你写软件，并认为自己的软件没有bug的，那是自己骗自己。有很多软件工具可以帮你在bug找你之前先找到它们。好了，此处我不得不承认我还只是个新手，我还不是特别熟悉这块有些什么。（太不好意思了！）但是我确实足够了解该建议看什么地方。一些主要的类别如下： 静态分析工具。这类软件解析你的软件，或者通过未处理的源码，或者通过编译后的对象文件。最著名的例子是C的lint。lint像是你高中的英语老师，他/她在你的试卷上到处画红叉，抱怨你用“who”代替了“whom”，或者句子里你用的介词结尾。要用英语有效地交流，你用得着严格遵循这些规则吗？不，但是这样做有助于你预防错误。C语言里也是如此——避免写某种差劲的模式的代码可以帮助你预防错误，而lint是帮你找到那些模式的。Java有FindBugs，而其他的编程语言也有类似的程序。在这类软件里同样会计算代码复杂度——好的软件设计通常使函数保持短小。如果你发现你写的函数超过20-30行，你或许可以把它们分成更小的单元，这样更容易设计和调试。 单元测试和代码覆盖率。通常认为测试大型软件包是及其困难的，而在单个代码模块上写尝试各种输入模式的单元测试来测试较小的软件模块比较容易。在嵌入式系统里单元测试可以很难。一种方法是在PC上交叉编译软件，并寄希望于你的软件里的任何bug可以在PC编译版本里被检测到。当你能够写自动测试脚本也是有希望的。这样当你对你的软件做了修改，你可以运行自动测试脚本，检查是否引入了新bug。对于代码覆盖率，我在医疗工业里的同事使用Cantata++。它不便宜，但是这些可是医疗设备。 代码“美化器”——如果你和同事都使用相同的代码，那你可以更容易的找到低级的语法bug。正常情况我们都有自己的风格，但是这里就有软件可以自动缩进，把制表符转为空格或等价的东西。我考虑过的有一个叫做Uncrustify，附有一个图形用户界面叫做UniversalIndentGUI。 （推荐阅读伯乐在线之前的这篇文章《代码美化与格式化工具》） 10. 基本命令行应用工具下面的很多程序都是UNIX的命令行应用工具，它们出生在还没有图形用户界面，事情都需要靠手动去完成的日子。除非现在图形用户界面有革命性的改进，否则通过命令行，你能做的总是更多些，因为你通过脚本可以完成更多种事情的组合。如果你运行的是OSX或者Linux，你已经有这些工具了。如果你运行的是Windows，你可以去http://unxutils.sourceforge.net/ 或 http://sourceforge.net/projects/unxutils/下载能运行在你的操作系统上的二进制版本。 less——这也许是我用的最多的。它能够显示文件逐页显示文件内容。你还可以查找文本内容，或者如果你在看一个正在不断更新的日志文件，你可以按下F，然后它会给你显示最新加入的行。 grep——能用正则表达式搜索一组文件。 touch——更新文件的最近修改时间为当前日期/时间，或者如果文件不存在，它会创建一个空文件。 tee——通过tee传送管道命令（例如 someprog | tee logfile）让你复制那个命令的输出到文件，并同时在终端打印输出。 which——如果你在终端运行一个程序foo.exe，你想要知道该程序在什么位置，只需要输入which foo.exe head和tail——这两个让你打印出文件的头N行或后N行 uniq——过滤输出，移除连续的相同行 du——打印一个目录的磁盘使用率（总占用空间） wc——统计文件的行数，单词数和字符数。（当我给编辑写信时我会用它，这样我可以保持我的字数在新闻能允许的最大字数内） cp，rm，mv，ls，cat——这些都有DOS下的等价命令（copy，delete，rename，dir，type），但是这些UNIX的等价命令有时候在脚本里用到，所以我把它们安装到我的path下。 md5sum——在对通过计算文件的MD5哈希码来验证文件完整性时有用 gzip和gunzip——这两个是压缩和解压缩单个文件的。.gz格式较.zip普及程度低一点，但是你偶尔能见到它。 wget和curl——这两个程序可以让你下载网页。 参考：你应该知道的10种软件工具]]></content>
      <categories>
        <category>程序员</category>
      </categories>
      <tags>
        <tag>程序员</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo遇到的坑]]></title>
    <url>%2FBolgBuild%2F2018%2F01%2F03%2FBlogBuild%2FHexo%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Hexo遇到的坑1. imagemin使用npm install hexo-imagemin –save安装imagemin后在根目录 _cofig.yml中配置imagemin如下。 imagemin: enable : true interlaced : false multipass : false optimizationLevel: 2 pngquant : false progressive: false 会有一些图片在 hexo g命令后生成的是0kb，根本打不开，注释掉_cofig.yml中关于imagemin的配置，生成的图片还是0kb，使用npm uninstall hexo-imagemin命令卸载后，就解决了了问题。]]></content>
      <categories>
        <category>BolgBuild</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>BolgBuild</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客Next主题如何添"ForkMeOnGithub"]]></title>
    <url>%2FBolgBuild%2F2017%2F12%2F29%2FBlogBuild%2FHexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0ForkMeOnGithub%2F</url>
    <content type="text"><![CDATA[Hexo博客Next主题如何添加”ForkMeOnGithub”如何给网站添加”Fork me on Github”效果？ 1. 效果图展示 2. 实现1. 样式挑选样式可以参考github的文档,可以选择左侧样式还是右侧样式， 2. 修改把官网的的代码拷贝过来添加到Hexo博客根目录/themes/next/layout文件夹下的_layout.swig文件中官网的代码： 123&lt;a target="_blank" href="https://github.com/you"&gt;&lt;img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"&gt;&lt;/a&gt; 比如我的github地址为:https://github.com/Seachal所以代码如下:1234567&lt;body&gt;...&lt;a target="_blank" href="https://github.com/Seachal"&gt;&lt;img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"&gt;&lt;/a&gt;...&lt;/body&gt; 3. 有何问题但是这样会有个问题：手机上的页面也会是这个效果,如果你不想让手机上显示成 那么你需要 修改文件hexo博客根目录\themes\next\layout\_layout.swig 找到如下代码块 1234&lt;html class="&#123;&#123; html_class | lower &#125;&#125;"&gt;&lt;head&gt; &#123;% include '_partials/head.swig' %&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; 添加代码，结果如下: 1234567891011121314151617&lt;head&gt; &#123;% include '_partials/head.swig' %&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt; &#123;% include '_third-party/analytics/index.swig' %&#125; &lt;style&gt; .forkMeOnGithub&#123; display: none; &#125; @media (min-width: 768px) &#123; .forkMeOnGithub&#123; display: inline; &#125;&#125;&lt;/style&gt;&lt;/head&gt; 最后在2.1节添加的代码块上套上div加上class就行了，代码如下 123&lt;div class="forkMeOnGithub"&gt;&lt;a target="_blank" href="https://github.com/Seachal"&gt;&lt;img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"&gt;&lt;/a&gt;&lt;/div&gt; 这样就只会在桌面版的网页内显示”Fork me on Github”]]></content>
      <categories>
        <category>BolgBuild</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>BolgBuild</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android设置TextView文显示固定字数 省略号表示多余部分]]></title>
    <url>%2FAndroid%2F2017%2F12%2F28%2FAndroid%2FAndroid%E8%AE%BE%E7%BD%AETextView%E6%96%87%E6%98%BE%E7%A4%BA%E5%9B%BA%E5%AE%9A%E5%AD%97%E6%95%B0%20%E7%9C%81%E7%95%A5%E5%8F%B7%E8%A1%A8%E7%A4%BA%E5%A4%9A%E4%BD%99%E9%83%A8%E5%88%86%2F</url>
    <content type="text"><![CDATA[Android设置TextView文显示固定字数 省略号表示多余部分今天在设置TextView文显示固定字数 省略号表示多余部分时，发现android:maxLines和android:ellipsize这两个属性同时使用并没有效果。原因： 把 android:layout_height=&quot;match_parent&quot;改为 android:layout_height=&quot;wrap_content&quot;就有效果了。 ##更多代码在xml中： 123android:ellipsize=&quot;start&quot; 省略号在开头android:ellipsize=&quot;middle&quot; 省略号在中间android:ellipsize=&quot;marquee&quot; 跑马灯 在java文件中： 123tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;START&quot;));tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;MIDDLE&quot;));tv.setEllipsize(TextUtils.TruncateAt.valueOf(&quot;MARQUEE&quot;));]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TextView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态为TextView控件设置drawableLeft图标,并设置间距]]></title>
    <url>%2FAndroid%2F2017%2F12%2F28%2FAndroid%2F%E5%8A%A8%E6%80%81%E4%B8%BATextView%E6%8E%A7%E4%BB%B6%E8%AE%BE%E7%BD%AEdrawableLeft%E5%9B%BE%E6%A0%87%2C%E5%B9%B6%E8%AE%BE%E7%BD%AE%E9%97%B4%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[动态为TextView控件设置drawableLeft图标,并设置间距重要属性: textView.setCompoundDrawablePadding(4);//设置图片和text之间的间距 textView.setPadding(-5, 0, 0, 0);//设置整体的padding 代码如下: 12345678910private void addDrwable(TextView textView) &#123; //获取图片 Drawable drawable = ContextCompat.getDrawable(mContext, R.drawable.staff_portrait); drawable.setBounds(0, 0, drawable.getMinimumWidth() / 2, drawable.getMinimumHeight() / 2); //在左侧添加图片 textView.setCompoundDrawables(drawable, null, null, null); //textView.setCompoundDrawablesRelative(drawable, null, null, null); textView.setCompoundDrawablePadding(5);//设置图片和text之间的间距 textView.setPadding(25, 0, 0, 0); &#125; 存在问题TextView的属性Gravity对添加的图片无效，如Gravity的值为center，图片会居左，文字相对于无图片时的位置偏右了一点。所以只能被迫选择列表中的数据全部由居中给为居左]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>TextView</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo创建文章和草稿]]></title>
    <url>%2FBolgBuild%2F2017%2F12%2F25%2FBlogBuild%2F2018-01-04%2F</url>
    <content type="text"><![CDATA[#首先安装gulp，执行以下命令： 1npm insatll gulp -g 1npm install gulp-htmlclean]]></content>
      <categories>
        <category>BolgBuild</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>BolgBuild</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo创建文章和草稿]]></title>
    <url>%2FBolgBuild%2F2017%2F12%2F25%2FBlogBuild%2F2017-12-30-1%2F</url>
    <content type="text"><![CDATA[Hexo创建文章和草稿文章命令行中输入： ======================== $ hexo new “new article” ======================== 之后在source/_posts目录下面，多了一个new-article.md的文件。 打开之后我们会看到： ========================= title: new article date: 2014-11-01 20:10:33 tags: ========================= 文件的开头是属性，采用统一的yaml格式，用三条短横线分隔。下面是文章正文。 文章的正文支持markdown格式，建议你先学习一下它的语法。markdown不像html似的一大堆标签，很简单，只有几个符号。 新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。 属性文章可以拥有如下属性： Setting Description Default layout Layout post或page title 文章的标题 date 创建日期 文件的创建日期 updated 修改日期 文件的修改日期 comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字 文件名 动态博客中通过发布文章页面设置的各种属性，在hexo里要这样设置。 分类和标签例如： =========== categories: 日记 tags: Hexo node.js =========== 摘要同wordpress一样，之上的内容为摘要。 layout如果你修改了layout，在scaffolds文件夹里一定要有名字对应的模版文件，否则会采用默认模版。 文件名在配置文件中的new_post_name项可以设置文件名，默认为:title，也就是你在命令行输入的名字。 文件名可以为下面几个变量和字符串常量的任意组合： Variable Description :title Escaped title (lower case and replace spaces with dash) :year Created year (4-digit) :month Created month (2-digit) :i_month Created month (Without leading zeros) :day Created day (2-digit) :i_day Created day (Without leading zeros) 草稿草稿相当于很多博客都有的“私密文章”功能。 ============================ $ hexo new draft “new draft” ============================ 会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。 如果你希望强行预览草稿，更改配置文件： =================== render_drafts: true =================== 或者，如下方式启动server： ====================== $ hexo server –drafts ====================== 下面这条命令可以把草稿变成文章，或者页面： ================================== $ hexo publish [layout] ==================================]]></content>
      <categories>
        <category>BolgBuild</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>BolgBuild</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在Mac下配置Github和Bitbucket的SSH]]></title>
    <url>%2FGithub%2F2017%2F12%2F23%2F%E5%A6%82%E4%BD%95%E5%9C%A8Mac%E4%B8%8B%E9%85%8D%E7%BD%AEGithub%E5%92%8CBitbucket%E7%9A%84SSH%2F</url>
    <content type="text"><![CDATA[如何在Mac下配置Github和Bitbucket的SSH第一步：生成 SSH 公钥过程大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。 1.查看是否已经有了SSH密钥 首先先确认一下是否已经有一个公钥了。SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看： 1cd ~/.ssh 如果没有密钥则不会有此文件夹，有则备份删除 12cp -R ~/.ssh ~/.ssh_bakrm -R ~/.ssh 2.生成密钥1ssh-keygen -t rsa -C "你在Github上的邮箱" 第一次要输入file名字，直接回车即可，默认文件名为id_前缀，然后会被要求输入个密码并且确认。 第二步：添加密钥到SSH12cd ~/.sshssh-add -K id_rsa 需要刚才生成密钥时候输入的密码。 在github上添加SSH Key1more id_rsa.pub 查看公钥里的内容并且全部复制下来(包括开头ssh-rsa和结尾邮箱)。 进入到github的setting，找到SSH Keys页面添加一个key，title随意，赋值公钥进去保存即可。 第三步：测试是否成功1ssh git@github.com 成功则返回类似: 12Hi Seachal! You've successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed. BitbucketBitbucket.org是一个和Github极其类似的托管库网站，但是他的私有库是免费的，所以一般我们会把私有库放到bitbucket上，而其他库放到github上，毕竟github的SNS属性稍微多些，开源的库就尽量的希望有与其他人的更多互动。给bitbucket添加SSH Key实际上是一样的。测试bitbucket ssh是否可连接 1ssh -T git@bitbucket.org 成功则返回类似: 123logged in as Seachal.You can use git or hg to connect to Bitbucket. Shell access is disabled.]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio快捷键_Mac和Windos和Linux]]></title>
    <url>%2FAndroid%2F2017%2F12%2F23%2FAndroid%2FAndroid%20Studio%E5%BF%AB%E6%8D%B7%E9%94%AE_Mac%E5%92%8CWindos%E5%92%8CLinux%2F</url>
    <content type="text"><![CDATA[Android Studio 为许多常用操作提供了键盘快捷键。 下表按操作系统显示了默认键盘快捷键，包括 Mac 、Windows、Linux 等系统。 说明 Mac Windows/Linux 常规 全部保存 Command + S Control + S 同步 Command + Option + Y Control + S 最大化/最小化编辑器 Control + Command + F12 Control + Shift + F12 添加到收藏夹 Option + Shift + F Alt + Shift + F 使用当前配置文件检查当前文件 Option + Shift + I Alt + Shift + I 快速切换模式 Control + `（反引号） Control + `（反引号） 打开设置对话框 Command + ,（英文逗号） Control + Alt + S 打开项目结构对话框 Command + ;（英文分号） Control + Alt + Shift + S 在标签和工具窗口之间切换 Control + Tab Control + Tab 在 Studio 内导航和搜索 搜索全部内容（包括代码和菜单） 按两次 Shift 按两次 Shift 查找 Command + F Control + F 查找下一个 Command + G F3 查找上一个 Command + Shift + G Shift + F3 替换 Command + R Control + R 查找操作 Command + Shift + A Control + Shift + A 按符号名称搜索 Command + Option + O Control + Alt + Shift + N 查找类 Command + O Control + N 查找文件（而不是类） Command + Shift + O Control + Shift + N 在路径中查找 Command + Shift + F Control + Shift + F 打开文件结构弹出式菜单 Command + F12 Control + F12 在打开的编辑器标签之前导航 Control + 向右/向左箭头 Alt + 向右/向左箭头 跳到源代码 F4 / Command + 向下箭头 F4 / Control + Enter 在新窗口中打开当前编辑器标签 Shift + F4 Shift + F4 最近打开的文件弹出式菜单 Command + E Control + E 最近编辑的文件弹出式菜单 Command + Shift + E Control + Shift + E 转到上一个编辑位置 Command + Shift + 退格键 Control + Shift + 退格键 关闭活动编辑器标签 Command + W Control + F4 从工具窗口返回到编辑器窗口 Esc Esc 隐藏活动或上一个活动工具窗口 Shift + Esc Shift + Esc 转到行 Command + L Control + G 打开类型层次结构 Control + H Control + H 打开方法层次结构 Command + Shift + H Control + Shift + H 打开调用层次结构 Control + Option + H Control + Alt + H 编写代码 生成代码（getter、setter、构造函数、 hashCode/equals、toString、新文件、新类） Command + N Alt + Insert 替换方法 Control + O Control + O 实现方法 Control + I Control + I 控制语句 (if…else / try…catch / etc.) Command + Option + T Control + Alt + T 删除插入符处的行 Command + 退格键 Control + Y 折叠/展开当前代码块 Command + 减号/加号 Control + 减号/加号 折叠/展开所有代码块 Command + Shift + 减号/加号 Control + Shift + 减号/加号 复制当前行或选择 Command + D Control + D 基本代码自动完成 Control + 空格键 Control + 空格键 智能代码自动完成（按预期 类型过滤方法和变量列表） Control + Shift + 空格键 Control + Shift + 空格键 完成语句 Command + Shift + Enter Control + Shift + Enter 快速文档查找 Control + J Control + Q 显示选定方法的参数 Command + P Control + P 转到声明（直接） Command + B 或 Command + 点击 Control + B 或 Control + 点击 转到实现 Command + Alt + B Control + Alt + B 转到超类方法/超类 Command + U Control + U 打开快速定义查找 Command + Y Control + Shift + I 切换项目工具窗口的可见性 Command + 1 Alt + 1 切换书签 F3 F11 通过助记切换书签 Option + F3 Control + F11 通过行注释添加注释/取消注释 Command + / Control + / 通过块注释添加注释/取消注释 Command + Shift + / Control + Shift + / 选择连续增加的代码块 Option + Up Control + W 将当前选择退回到上一个状态 Option + Down Control + Shift + W 移动到代码块起始位置 Option + Command + [ Control + [ 移动到代码块结束位置 Option + Command + ] Control + ] 从当前位置选择到代码块起始位置 Option + Command + Shift + [ Control + Shift + [ 从当前位置选择到代码块结束位置 Option + Command + Shift + ] Control + Shift + ] 从当前位置删除到单词结尾 Option + Delete Control + Delete 从当前位置删除到单词开头 Option + 退格键 Control + 退格键 优化导入 Control + Option + O Control + Alt + O 项目快速修复 （显示意图操作和快速修复） Option + Enter Alt + Enter 重新格式化代码 Command + Option + L Control + Alt + L 自动缩进行 Control + Option + I Control + Alt + I 缩进/取消缩进行 Tab/Shift + Tab Tab/Shift + Tab 智能行合并 Control + Shift + J Control + Shift + J 智能行拆分 Command + Enter Control + Enter 开始新行 Shift + Enter Shift + Enter 下一个/上一个突出显示的错误 F2 / Shift + F2 F2 / Shift + F2 构建并运行 构建 Command + F9 Control + F9 构建并运行 Control + R Shift + F10 调试 调试 Control + D Shift + F9 跳过 F8 F8 逐步执行 F7 F7 智能逐步执行 Shift + F7 Shift + F7 跳出 Shift + F8 Shift + F8 运行到光标位置 Option + F9 Alt + F9 评估表达式 Option + F8 Alt + F8 继续运行程序 Command + Option + R F9 切换断点 Command + F8 Control + F8 查看断点 Command + Shift + F8 Control + Shift + F8 重构 复制 F5 F5 移动 F6 F6 安全删除 Command + Delete Alt + Delete 重命名 Shift + F6 Shift + F6 更改签名 Command + F6 Control + F6 内联 Command + Option + N Control + Alt + N 提取方法 Command + Option + M Control + Alt + M 提取变量 Command + Option + V Control + Alt + V 提取字段 Command + Option + F Control + Alt + F 提取常量 Command + Option + C Control + Alt + C 提取参数 Command + Option + P Control + Alt + P 版本控制/本地历史记录 将项目提交到 VCS Command + K Control + K 从 VCS 更新项目 Command + T Control + T 查看最近变更 Option + Shift + C Alt + Shift + C 打开 VCS 弹出式菜单 Control + V Alt + `（反引号）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Android</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[app目录下的build.gradle详解]]></title>
    <url>%2FAndroid%2F2017%2F07%2F23%2FAndroid%2Fapp%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84build.gradle%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[app目录下的build.gradle详解表示这是一个Android程序模块，如果是作为库，就声明为Library'com.android.library'123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778applyplugin:&apos;com.android.application&apos;android &#123;compileSdkVersion26// 编译版本，指用哪个版本的SDK进行编译buildToolsVersion&quot;26.0.1&quot;//构建工具//对项目的更多细节进行配置defaultConfig &#123;applicationId&quot;com.seachal.myapplicationtestlog&quot;minSdkVersion19targetSdkVersion26versionCode1versionName&quot;1.0&quot;testInstrumentationRunner&quot;android.support.test.runner.AndroidJUnitRunner&quot;&#125;//指定生成安装文件的相关配置buildTypes &#123;//release 闭包用于指定生成正式版安装文件的配置release &#123;minifyEnabledfalse//指定是否对项目的代码进行混淆， true 表示混淆， false 表示不混淆。//proguard-android.txt在默认的SDK目录下，有通用的混淆规则// proguard-rules.pro 有本项目专用的混淆规则proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;),&apos;proguard-rules.pro&apos;&#125;//debug闭包可以忽略不写&#125;&#125;dependencies &#123;//本地依赖声明，它表示将 libs 目录下所有.jar 后缀的文件都添加到项目的构建路径当中compile fileTree(dir:&apos;libs&apos;,include: [&apos;*.jar&apos;])androidTestCompile(&apos;com.android.support.test.espresso:espresso-core:2.2.2&apos;, &#123;excludegroup:&apos;com.android.support&apos;,module:&apos;support-annotations&apos;&#125;)// 远程依赖声明compile&apos;com.android.support:appcompat-v7:26.+&apos;//com.android.support.constraint 是域名。constraint-layout是组名，用于区分同一公司的不同库。 1.0.2是版本号compile&apos;com.android.support.constraint:constraint-layout:1.0.2&apos;//compile project(&apos;:helper&apos;) //库依赖声明格式，表示依赖了一个叫helper的Library// 声明测试用例库testCompile&apos;junit:junit:4.12&apos;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>gradle</tag>
        <tag>配置</tag>
        <tag>含义</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PyCharm与IntelliJ IDEA Python插件FAQ]]></title>
    <url>%2FIDE%2F2017%2F07%2F10%2F2018-01-10-1%2F</url>
    <content type="text"><![CDATA[PyCharm与IntelliJ IDEA Python插件FAQPyCharm与IntelliJ IDEA + Python插件 问：随着PyCharm的宣布，IDEA插件仍然可用？答：是的，我们计划同步发布新的PyCharm构建和插件更新。对于购买了IntelliJ IDEA Ultimate许可证的用户，该插件将保持免费。 问：插件是否支持PyCharm支持的大部分/全部功能？答：IntelliJ IDEA的Python插件是与PyCharm相同的代码库构建的。有些功能可能暂时在插件中不可用，因为与PyCharm相比，最新的IntelliJ IDEA基于早期的IntelliJ平台。 问：PyCharm和Python插件有什么不同？使用PyCharm而不仅仅是插件会有好处吗？答：PyCharm在一些领域提供了一个更简单的用户界面，例如项目管理，IDE设置等。 Python插件依次具有Jython全面的支持功能（跨语言导航，完成和重构）。PyCharm仅支持Jython作为运行应用程序的运行时。 如果你不使用Java / Python集成，PyCharm是一个更好的开始。 问：我可以使用我的IntelliJ IDEA许可证使用PyCharm吗？答：不可以。这两种产品使用不同的许可证制度。如果您想使用这两种产品，则需要购买两个许可证。 问：IntelliJ IDEA和PyCharm之间的项目文件是否兼容？答：在PyCharm中创建的项目可以在安装了Python插件的IntelliJ IDEA中打开，没有任何问题。IntelliJ IDEA允许更灵活的项目配置，例如为项目配置库的可能性。PyCharm将能够打开并使用更高级设置的项目，但是您将无法更改PyCharm中的设置。参考：https://confluence.jetbrains.com/display/PYH/PyCharm+vs.+IntelliJ+IDEA+Python+plugin+FAQ]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IntelliJ</tag>
        <tag>IDE</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[about]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[Zhang Seachal，坐标北京，专注 Android 经验分享，性情中人。 写博客的初衷：总结经验，记录自己的成长。]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[uploads]]></title>
    <url>%2Fuploads%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
